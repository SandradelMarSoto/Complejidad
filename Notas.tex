\documentclass{homework}

% S\'imbolos
\usepackage{recycle}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}

\usepackage[utf8]{inputenc}


% Figuras
\usepackage{graphicx}
\usepackage{float}

% Gr\'aficas
\usepackage{tikz}

% Estilo Tikz
\tikzstyle{edge}=[shorten <=2pt, shorten >=2pt,
                  >=stealth, line width=1.1pt]
\tikzstyle{vertex}=[circle, fill=white, draw,
                    minimum size=5pt,
                    inner sep=0pt, outer sep=0pt]
\tikzstyle{blackV}=[circle, fill=black, draw,
                    minimum size=5pt,
                    inner sep=0pt, outer sep=0pt]


%Quitamos la sangría
\setlength\parindent{0pt}


\begin{document}
\section*{\LARGE{Notas del Curso de Complejidad 2021-1}}

\section{M\'aquinas de Turing}

\subsection{Introducci\'on}
En 1906 se declara el Problema 10 de Hilbert:
¿Existe un algoritmo que decida si una ecuación diofantina dada (con cualquier mínimo de variables) tiene solución (entera)?

En 1928 se genera el problema de Hilbert-Ackermann :
¿Hay un algoritmo que dado un enunciado, un conjunto de axiomas y un conjunto de reglas de inferencias, decida si el enunciado se puede deducir a partir de los axiomas mediante las reglas de inferencia?

Leibniz propuso el tener "un tipo de álgebra en el que todas las verdades de la razón pudieran reducirse a algún tipo de cálculo"\\

Un problema de decisión P lo podemos pensar como $f : A \rightarrow \{0,1\}$ donde $A$ es el conjunto de instancias (o entradas) de P.
$f^{y}[0]$ conjunto de no-instancias
$f^{y}[1]$ conjunto de sí.instancias

\subsection{M\'aquina de Turing}
$\bf{Def}$ Una Máquina de Turing es una noneta ordenada $M = (Q, \Sigma, \Gamma,\sqcup, \vdash, \delta, q_0, q_a, q_r )$
\begin{itemize}
	\item $Q$ es un conjunto no vacío (de entrada)
	\item $\Sigma$ es un conjunto no vacío (alfabeto de entrada)
	\item $\Gamma$ es un conjunto no vacío (alfabeto de cinta)
	\item $\delta : Q' \times \Gamma \rightarrow Q \time \Gamma \times \{L,R\}$ donde $Q' = Q - \{q_0, q_r\}$
	\item $q_0 \in Q$ (estado inicial)
	\item $q_a \in Q$ (estado aceptación) Estado de paro
	\item $q_r \in Q$ (estado rechazo) Estado de paro
	\item $\sqcup \in \Gamma - \Sigma$ (símbolo en blanco)
	\item $\vdash \in \Gamma - \Sigma$ (marcador o delimitador izquierdo de inicio de cinta)
\end{itemize}

Para cualquier $q \in Q$ existe $p \in Q$ tal que $\delta(q, \vdash) = (p, \vdash, R)$\\

Una configuración de la máquina de Turing se determina por:
\begin{itemize}
	\item Estado $q$
	\item Posición de la cabeza
	\item Contenido de la cinta $uv$
\end{itemize}
La configuración se ve como $uqv$, $q$ es el cabezal que se encuentra en la primera posición de $v$.

Ejemplo: Si $M$ tiene entrada $w$ su posición inicial es $q_0 \vdash w$

La configuración $\alpha$ da lugar a la configuración $\beta$ $\alpha \rightarrow \beta$ y se define como sigue:
\begin{itemize}
	\item $\alpha \rightarrow^{0} \alpha$
	\item Diremos que $\alpha \rightarrow^{n+1} \beta$ si existe una configuración $\Gamma$ tal que $\alpha \rightarrow^{n} \Gamma$ y $\Gamma \rightarrow \beta$
	\item $\alpha \rightarrow^{*} \beta$ si $\alpha \rightarrow^{n} \beta$ para algún $n \in \mathds{N}$
\end{itemize}

Una configuración e aceptación (o rechazo) es cualquiera en la que el estado sea $q_a$ (ó $q_r$). Éstas configuraciones son de paro.\\

Si T es una MT y $w \in \Sigma^{*}$ se dice que T acepta $w$ si $q_0 \rightarrow^{n} xq_ay$ para cadenas $x, y \in \Sigma^{*}$.

El lenguaje de T, L(T) es el conjunto L(T) = $\{x \in \Sigma^{*} | T \text{ acepta a } x\}$.

Si L $\subseteq \Sigma^{*}$ es un lenguaje, se dice que T acepta a L si L(T) = L.

Los lenguajes regulares pueden ser reconocidos por un autómata finito determinista 

$\bf{Algoritmo}$ Algoritmo para convertir de DFA (autómata finito determinista) a TM (máquina de Turing)
\begin{enumerate}
	\item Copiar cada estado
	\item Cambiar cada transición con etiqueta $'x'$ por una con etiqueta $'x/x,R'$
	\item Agregar un estado de aceptación
	\item Para cada estado final en el autómata, agregarle una transición $\sqcup / \sqcup, R$
\end{enumerate}

¿Cómo describimos las máquinas de Turing? Con pseudocódigo
Ejemplo:
Describimos la máquina de Turing que obtiene las potencias de dos como sigue:
M = "Con entrada $\vdash w$:
\begin{enumerate}
	\item Recorre la cinta de izquierda a derecha, tachando un cero no y uno si
	\item Si en 1 la cinta contenía un único cero, $\underline{acepta}$
	\item Si en 1 la cinta contenía más de un creo, y un número impar de ceros, entonces $\underline{rechaza}$
	\item Regresa el cabezal a extremo izquierdo de la cinta
	\item Va a 1"
\end{enumerate}

Las máquinas de Turing pueden computar funciones parciales.

Tenemos $f : D \rightarrow C$  $D \subseteq \Sigma^{*}$ $C \subseteq \Gamma^{*}$.

$\bf{Def.}$ Sea R una MT, $k$ un natural y $f$ una función parcial sobre $(\Sigma^{*})^{k}$ con valor en $\Gamma^{*}$. Decimos que T computa a $f$ si para cada $(x_1, ..., x_k)$ en el dominio de $f$, 
$q_0 \vdash x_1 \sqcup x_2 \sqcup ... \sqcup x_k \rightarrow^{k} q_0 \vdash f(x_1, ..., x_k)$
y ninguna otra entrada que sea una $k$-ada de cadenas es aceptada por T. 

Una función parcial $f: (\Sigma^{*})^{k} \rightarrow \Gamma^{*}$ es Turing-computable (computable) si hay una máquina de Turing que la computa.

Al fijar el contradominio y la aridad de la función, entonces una MT calcula una única función parcial.\\

Una tercera opción del cabezal de la MT es quedarse en su lugar después de hacer algo (S). 
$\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,R,S\}$.

$M_1$ tiene "la opción" $S$
$M_2$ no tiene "la opción" $S$ pero reconoce el mismo lenguaje que $M_1$ o computa la misma función.

Simulo una máquina de Turing que tiene la opción S con una máquina de Turing que no la tiene al poner un estado adicional, donde en las transiciones se escribe lo mismo que lea y se mueva a la derecha, luego se escriba lo mismo que lea y se mueva a la izquierda.\\

Algunas MT útiles que regresan el cabezal a donde estaba originalmente:
\begin{itemize}
	\item NB (Next Blank)
	\item PB (Previous Blank)
	\item Copy ($\vdash x \rightarrow x \sqcup x$)
	\item Insert($\sigma$)
	\item "Borrar la cinta" (Ponemos un delimitador derecho y borramos todo a su izquierda)
	\item Compare ($\vdash x \sqcup y$ acepta si $x=y$ o rechaza si $x \neq y$)
	\item R (Reverse)
\end{itemize}
Copy $\rightarrow$ NB $\rightarrow$ R $\rightarrow$ PB $\rightarrow$ Equal (Esta máquina de Turing reconoce palíndromos)


\subsection{M\'aquinas de Turing multicintas}
Una MT multicinta es como una MT pero tiene $k$ cintas de memoria. Su definición solo difiere respecto a una MT usual en la función de transición
$\delta : Q \times \Gamma^{k} \rightarrow Q \times \Gamma^{k} \times \{L, R, S\}^{k}$.
$\delta(q_1, a_1,...,a_k) = (q_1,b_1,...,b_k, D_1,...,D_k)$ $D_i \in \{L,R,S\}$.

Las máquinas de Turing multicinta no tienen más poder que las de una cinta.
Para simularlas en una máquina de Turing de una cinta podemos usar bloques como letras de alfabeto y manejamos la posición del cabezal como un puntito en las distintas letras. Le hace una pasada para ver los cabezales y luego realiza otra para hacer las transiciones. La memoria está en la estructura de los estados (el control finito).
Otra manera es que los espacios pares simulen una cinta y los impares otra (es trivial generalizarlo a $k$). Pero usaremos la siguiente:

$\bf{Teorema}$ Toda MT multicinta tiene una MT de una sola cinta equivalente.

Dem: Construimos, dada una MT multicinta M a la MT de una sola cinta S t.q. tiene los contenidos de las cintas de M en su cinta, separados por un símbolo especial $\#$, y usando versiones especiales de cada símbolo en $\Gamma_M$ para denotar donde están los cabezales $\dot{o}$

S = Con entrada $w_1,...,w_n$
\begin{enumerate}
	\item Poner su cinta en el formato que representa las k cintas. La cinta formateada se ve como $| \vdash | w_1 | ... | w_n | \# | \sqcup | \# | \sqcup | ...|$.
	\item Para simular un movimiento, S recorre la cinta desde $\vdash$  donde hasta el último $\#$, para determinar los símbolos que están leyendo los k cabezales. Después S hace una segunda pasada para actualizar las cintas de acuerdo a la función de transición de M.
	\item Si en cualquier punto, S mueve alguna de las cabezas virtuales hacia la almohadilla ($\#$) de la derecha, en M entonces el cabezal correspondiente se movió a un espacio en blanco. Luego, basta con que se inserte un símbolo blanco en esa posición.
\end{enumerate}


$\bf{Corolario}$ Si L es un lenguaje, entonces L es Turing-reconocible si y sólo si L es reconocido por alguna MT multicinta.

Dem: Toda MT es una MT multicinta.

La otra implicación es el teorema anterior $\blacksquare$

\subsection{M\'aquinas de Turing no deterministas}

Se diferencian de las deterministas está en que tenemos una nueva función de transición:

$\delta : Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R, S\})$

Ya no es un algoritmo, sino que ahora la máquina “adivina” qué transición tomar para llegar al resultado.
Se dice que acepta si al menos un camino lleva a aceptación.
Se parecen a los autómatas no-deterministas.
No son implementables en la vida real.
Son equivalentes a una MT (usando una MT que haga BFS exhaustivo sobre el árbol de posibles configuraciones)
Es importante pensar en términos de que la máquina “adivina” la respuesta correcta (SOLO si existe).
Toda MT es MTN.

Ejemplo: Un número en unario ¿Es compuesto?
Aplica la siguiente combinación de MTs NB $\rightarrow$ G (Guess) $\rightarrow$ NB $\rightarrow$ G $\rightarrow$ PB $\rightarrow$ M (Multiply) $\rightarrow$ PB $\rightarrow$ Equal

¿Para qué sirven las MTN?
Estas máquinas teóricas realizan búsquedas exhaustivas “rápidamente”
Resuelven problemas lentos muy rápido.
“Si tuviéramos una MTN, podríamos resolver un montón de problemas que nos causan dolores de cabeza en la vida real”
Como por ejemplo factorización de números y polinomios, agente viajero, SAT, etc.\\


$\bf{Teorema}$ Toda MTN tiene una MTD equivalente.

Dem: Sea N una MTN, proponemos a M una MTD de 3 cintas.
\begin{itemize}
	\item En la primera cinta está la entrada y nunca se modifica.
	\item La segunda cinta es una copia de la cinta de N y se usa para simular a N
	\item La tercera cinta contiene las direcciones de los nodos del árbol de ejecución de N codificadas con $\Sigma = \{1, ..., b\}$ Existen direcciones inválidas.
\end{itemize}

M = "con entrada $w$
\begin{enumerate}
	\item Copia la cinta 1 a la 2
	\item Usa a la cinta 2 para simular a N con entrada $w$ en una rama de su cómputo no determinista.
	Antes de cada transición, consulta la cinta 3 para determinar que decisión tomar entre las distintas posibilidades no deterministas. Si no hay más símbolos en la cinta 3 o se llega a una dirección inválida, aborta y va a 3. Si encuentra una configuración de rechazo va a 3. Si encuentra una configuración de aceptación, $\underline{acepta}$
	\item Reemplaza la cadena en la cinta 3 por la siguiente en el orden canónico de $\{1,..,b\}^{*}$
	\item Va a 1"
\end{enumerate}

Si una MTN M se ejecuta hay 3 posibilidades:
\begin{enumerate}
	\item acepta Configuración de paro
	\item rechaza Configuración de paro
	\item se cicla
\end{enumerate}

$\bf{Corolario}$ Un lenguaje es reconocible si y sólo si alguna MTN lo reconoce.

Una MT que no se cicla es un decididor.

Un lenguaje L es Turing-decidible si existe un decididor que lo reconoce.

$\bf{Corolario}$ Un lenguaje es decidible si  sólo si alguna MTN lo decide.

Dem. La ida es trivial.
Para el regreso notemos que cada longitud de cadena es un nivel del árbol, así que mantenemos un booleano que es v si todas las ejecuciones han terminado (en la longitud actual) f e.o.c.
Cuando acaben las cadenas de longitud k, rechazamos si el booleano es v. En otro caso, vamos a la longitud k+1.

\subsection{Enumeradores}

Sea E una MT con $k$ cintas $k \in \mathds{Z}$ y sea $L \subseteq \Sigma^{*}$. Decimos que E $\underline{enumera}$ a L si:
\begin{enumerate}
	\item El cabezal de la primera cinta nunca se mueve a la izquierda, nunca escribe un espacio en blanco y nunca modifica un símbolo que ya escribió.
	\item Para cualquier $x \in L$ hay algún punto de la operación de E en la que la cinta 1 contiene $x_1 \# x_2 \# ... \# x_n \# x$ donde $x_i \in L$ p.c $1 \leq i \leq n$ y $x_1,...,x_n,x$ son todas distintas.
	Si L es finito no se imprimen símbolos después de la última $\#$.
\end{enumerate}

El lenguaje de E, es L, i.e. L(E) = L.\\

$\bf{Teorema}$: Sea $L \subseteq \Sigma^{*}$ un lenguaje. Entonces L es reconocible si y sólo si es enumerado por algún enumerador; además $L$ es decidible si y sólo si es enumerado en orden canónico por algún enumerador.

Demostración: Supongamos primero que L es decidible y sea M una MT que lo decide. Proponemos a E dado por 

E ="Ignora la entrada
\begin{enumerate}
	\item Genera la siguiente cadena $w$ en orden canónico de $\Sigma^{*}$
	\item Ejecuta M con entrada $w$ e imprime a $w$ si M acepta".
\end{enumerate}

Como M es un decididor para L, E va a recorrer todas las cadenas en $\Sigma^{*}$ y, en orden canónico, va a imprimir solamente las que están en L.

Supongamos que L es reconocido por M. Proponemos al enumerador E dado por:
E ="Ignora la entrada
\begin{enumerate}
	\item Para cada $i \in \mathds{N}$
	\item Genera la siguiente cadena si en orden canónico y le agrega a la lista $s_0, s_1,...,s_i$
	\item Ejecuta M por $i$ pasos con cada una de las entradas $s_0$ hasta $s_i$
	\item Si M acepta alguna de las entradas y no la había aceptado en una ejecución anterior, la imprime."
\end{enumerate}

Si tenemos $s_i$ y $s_k$ tal que $i < k$, 

Supongamos que E enumera a L. Proponemos a M para recorrer a L dado por:
M="Con entrada $w$:
\begin{enumerate}
	\item Ejecuta E. Cada vez que se imprima una cadena, la compara con $w$.
	\item Si $w$ se imprime en algún momento $\underline{acepta}$."
\end{enumerate}

Supongamos que E enumera a L en orden canónico, Proponemos a M dado por
M="Con entrada $w$:
\begin{enumerate}
	\item Ejecuta E. Cada vez que se imprima una cadena, la compara con $w$.
	\item Si $w$ se imprime en algún momento $\underline{acepta}$.
	\item Si la cadena impresa por $E$ supera a $w$ en orden canónico, $\underline{rechaza}$."$\blacksquare$
\end{enumerate}


\subsection{T\'esis Church-Turing}
Turing, Church, Goëdel et al formalizaron el concepto de algoritmo.

Los algoritmos desde el punto de vista intuitivo son equivalentes a las Máquinas de Turing.

Ejemplo:
I : G es gráfica

Q: ¿Es G conexa?

M= "Con entrada $<G>$ con $G$ una gráfica:
\begin{enumerate}
	\item Elige el primer vértice de $G$ y lo marca.
	\item Repite el siguiente paso hasta que no se marquen vértices nuevos.
	\item Para cada vértice en $G$, éste es marcado si es adyacente a algún vértice marcado.
	\item Revisa si todos los vértices están marcados. En tal caso $\underline{acepta}$, si no $\underline{rechaza}$".
\end{enumerate}

M decide A 

\subsection{Máquina Universal de Turing }

U: "Con entrada $<M,w>$ con $M$ una $MT$
 \begin{enumerate}
 	\item Simula a M con entrada a $w$
 	\item $\underline{Acepta}$ si M acepta, $\underline{rechaza}$ si M rechaza.
 \end{enumerate}

\section{Problema de aceptaci\'on}

$A_{AFD} = \{<A,w> | \text{El AFD A acepta a la cadena w}\}$

Problema $A_{AFD}$

I: Un AFD A y una cadena $w$

Q: ¿A acepta a $w$?\\

$\bf{Prop}$: $A_{AFD}$ es decidible.

Dem: Proponemos una MT $M$ que decida a $A_{AFD}$

$M$ = Con entrada $<A,w>$ con a un AFD y w una cadena:
\begin{enumerate}
	\item Simula A con entrada w.
	\item Si la simulación termina en un estado de aceptación, $\underline{acepta}$. Si no, $\underline{rechaza} \blacksquare$
\end{enumerate}

$\bf{Prop}$: $A_{AFN}$ es decidible

Dem: Proponemos una MTD N que decida a $A_{AFN}$

$N$ = "Con entrada $<B, w>$ con B un AFN y w una cadena:
\begin{enumerate}
	\item Construye una AFD A equivalente a B.
	\item Ejecuta M con entrada w.
	\item $\underline{Acepta}$ si M acepta y $\underline{rechaza}$ si M rechaza ".
\end{enumerate}

$A_{REX} = \{<R,w> | \text{R es una expresion regular que genera a w} \}$

$\bf{Prop}$: $A_{REX}$ es decidible

Dem: P = "Con entrada $<R, w >$ donde R es una regex y w una cadena:
\begin{enumerate}
	\item Construye un AFN A equivalente a R.
	\item Ejecuta N con entrada $<A,w>$
	\item Responde lo mismo que N".
\end{enumerate}


$E_{AFD}  = \{<A> | \text{A es un AFD con L(A)}=\emptyset\}$ 

$\bf{Prop}$: $E_{AFD}$ es decidible

Dem: T = "Con entrada $<A>$ donde A es un AFD:
\begin{enumerate}
	\item Marca el estado inicial de A.
	\item Repite hasta que no se marquen estados nuevos
	\item Marca todos los estados que tengan transición desde un estado marcado.
	\item  Si algún estado de aceptación está marcado, $\underline{rechaza}$. Si no, $\underline{acepta}$.
\end{enumerate}

$EQ_{AFD}  = \{<A,B> | \text{A y B son AFD tales que L(A)=L(B)}\}$ 

$\bf{Prop}$: $C, L(C) = L(A)\triangle L(B)$

Dem: F = "Con entrada $<A.B>$ donde A y B es un AFD:
\begin{enumerate}
	\item Construye a C tal que $L(C)=L(A)\triangle L(B)$
	\item Ejecuta a $T$ con entrada C
	\item  Si T acepta, $\underline{acepta}$. Si no, $\underline{rechaza} \blacksquare$.
\end{enumerate}


Función característica:
El conjunto $S \subseteq A$ $\chi_{S} : A \rightarrow \{0, 1\}$
$\chi_{S}(a) =$ 1 si $a \in S$ 0 si $a \notin S$

$\omega = \{0,1,2,3,...\} = \mathds{N}$
$(0,1,0,1,..)$ sería el conjunto de los impares.

$\mathcal{P}(\mathds{N}) \sim^{\mathds{N}} 2 = \{f: \mathds{N} \rightarrow \{0,1\}$

$\varphi : P(\mathds{N}) \rightarrow^{\mathds{N}} 2$
$A \mapsto \chi_{A}$
$\psi : 2 \rightarrow P(\mathds{N})$
$f \mapsto \{i \in \mathds{N} | f(i) = 1\}$

$\psi \cdot \varphi = 1_{P(\mathds{N})}$
$\varphi \cdot \psi = 1_{P(\mathds{N})}$

¿La potencia de los naturales es biyectable con las sucesiones binarias? $\mathds{N} \sim \mathcal{P}(\mathds{N})$
¿Los naturales y la potencia de los naturales no son biyectables?
$\mathds{N} \sim \mathds{N}_2$

Si fueran biyectables podrías tener:
$f: \mathds{N} \rightarrow^{\mathds{N}} 2$
Si f fuera suprayectiva entonces toda sucesión binaria aparecería en la lista (sería imagen de alguien).

$g: \mathds{N} \rightarrow 2$
$g(i) = 1 - f_{i}(i)$
$g = (1,0,1,1,...)$

Podemos llegar a contradicción porque:
$\exists n \in \mathds{N}$
$f_{n}(n) \not= g(n) = 1 - f_{n}(n) $!
Por lo tanto,
$\mathds{N} \nsim \mathcal{P}(\mathds{N})$
$\mathds{N} \nsim \mathds{N}_2$

"Nadie podrá expulsarnos de paraíso que Cantor ha creado"-Hilbert.\\

$\bf{Prop.}$ Existen lenguajes no reconocibles.

Dem: 
Si $\Sigma$ es contable, entonces $\Sigma^{*}$ es numerable.
Sea $\mathcal{M} = \{<M> | M es una MT\} \subset Sigma^{*}$
$|\mathcal{M} \leq \aleph_{0}$

Si $\mathcal{L}L$ es el conjunto de todos los lenguajes sobre el alfabeto $\Sigma$, afirmamos que $|\mathcal{L}| = |\mathds{N}_2|$

Por tanto, $|\mathcal{M}|< |\mathcal{L}|$
Es decir hay más lenguajes que MT. Así, debe haber lenguajes no reconocibles por MT alguna.

$\varphi : \mathcal{L} \rightarrow \mathds{N}_2$
Sea $S_0, S_1, S_2, ...$ el orden canónico de $Sigma^{*}$, y sea $\mathcal{L}$ un lenguaje sobre $Sigma^{*}$ $\blacksquare$\\

¿En general $S \sim P(S)$? $\underline{No}$

Sea $f: S \rightarrow P(S)$. Veamos que f no es suprayectiva. Proponemos $T = \{s \in S | s \notin f(s)\}$
Si $s \in T$ entonces $s \notin f(s)$ ($T \cup (S-T) = S$)
Si $s \notin T$ entonces $s \in f(s)$
Por tanto $T \neq f(s)$
$T \notin Im(f)\blacksquare$\\


$A,E,EQ$
$A_{TM} = \{<M \omega> | \text{M es una MT que acepta a la cadena} \omega\}$

$\bf{Obs}$. $A_{TM}$ es reconocible.
	U = Con entrada $<M, w>$ donde M es una MT
\begin{enumerate}
	\item Simula a M con entrada $w$
	\item Si M acepta, $\underline{acepta}$, si M rechaza, $\underline{rechaza}$
\end{enumerate}

$\bf{Prop}$. $A_{TM}$ no es decidible
Dem. Supongamos que sí, y sea R un decididor de $A_{TM}$
$R(<M,w>) = \{ \underline{acepta} \text{si M acepta a w}, \underline{rechaza} \text{si M rechaza a w}\}$
Construimos una MT D que usa a R como subrutina
D = "Con entrada $<M>$ dada $M$ es una $MT$:
\begin{enumerate}
	\item Ejecuta R con entrada $<M, <M>>$
	\item Si R acepta, $\underline{rechaza}$; si R rechaza, $\underline{acepta}$"
\end{enumerate}
$D(<M>) = \{ \underline{acepta} \text{si M no acepta a }<M>; \underline{rechaza} \text{si M acepta a }<M>\}$

$D(<D>) = \{ \underline{acepta} \text{si D rechaza a }<D>; \underline{rechaza} \text{si D acepta a }<D>\}$!
D $\underline{acepta}$ a D si y sólo si D $\underline{rechaza}$ a D! $\blacksquare$\\

$\bf{Def.}$: Un lenguaje L sobre $\Sigma$ es $\underline{co-reconocible}$ si $\Sigma(\Sigma^{*} - L)$ es reconocible.

$\bf{Prop.}$ Un lenguaje es decidible si y sólo si es reconocible y co-reconocible.

Dem: Sea A un lenguaje. Si A es decidible, entonces es reconocible. Sea M un decididor para A.
M = "Con entrada $w$:
\begin{enumerate}
	\item Ejecuta M con entrada $w$
	\item Si M acepta, $\underline{rechaza}$
	Si M rechaza, $\underline{acepta}$
\end{enumerate}
L(M')= A
Si A es reconocible y co-reconocible.
Proponemos una MT M que decide a A que usa a $M_1$ y $M_2$ que reconocen a A y $\barwedge{A}$ respectivamente.
M = "Con entrada w:
\begin{enumerate}
	\item Simula en paralelo a $M_1$ y $M_2$ con entrada w
	\item Si $M_1$ acepta, $\underline{acepta}$
	\item Si $M_2$ acepta, $\underline{rechaza} \blacksquare$\\
\end{enumerate}

$\bf{Cor}$: El complemento de $A_{TM}$ no es reconocible.

Dem: $A_{TM}$ es reconocible. Si su complemento fuera reconocible, entonces $A_{TM}$ sería decidible pero no lo es $\blacksquare$\\


$H_{TM} = \{<M,w> | \text{M es una MT y M se detiene con entrada w}\}$

$\bf{Prop}$: $H_{TM}$ es indecible

Dem: Supongamos que R decide $H_{TM}$
Proponemos la MT S, dada por:
S = " Con entrada $<M,w>$, donde M es una MT:
\begin{enumerate}
	\item Ejecuta a R con entrada <M,w>
	\item Si R rechaza, $\underline{rechaza}$
	\item Simula a M con entrada w
	\item Si M acepta, $\underline{acepta}$, si no, $\underline{rechaza}$"
\end{enumerate}
Claramente, S decide a $A_{TM}$! $\blacksquare$


$E_{TM} = \{<M> | L(M) = \emptyset\}$

 $\bf{Prop}$ $E_{TM}$ no es decidible.
 
 Dem. Por contradicción. Supongamos que sí es decidible y sea R un decididor para $E_{TM}$. Construimos a S un decididor para $A_{TM}$ dado por:
 S : "Con entrada $<M,w>$ donde M es una MT:
 \begin{enumerate}
 	\item Construye a la MT $M_1$ dada por:
 	$M_1$ = "Con entrada x:
 	\begin{enumerate}
 		\item Si $x \neq w$, rechaza
 		\item  Si $x = w$, corre a M con entrada w y acepta si M lo hace".
 	\end{enumerate}
 	\item Ejecuta R con entrada $<M_1>$
 	\item Si R acepta, $\underline{rechaza}$. Si R rechaza, $\underline{acepta}$".
 \end{enumerate}

El lenguaje de $M_1$ es $|w|$ o $\emptyset$ dependiendo de si M acepta o no a w respectivamente. Por tanto, S es un decididor para $A_{TM} \blacksquare$


Entonces $E_{TM}$ no es decidible

$REG_{TM} = \{<M> | M \text{es una Mt y L(M) es regular}\}$

$\bf{Prop.}$ $REG_{TM}$ es indecidible

Dem: Por contradicción. Sea R un decididor para $REG_{TM}$
Proponemos la MT S dada por:
S = " Con entrada $<M,w>$, donde M es una MT:
\begin{enumerate}
	\item Construye a la MT $M_2$ dada por:
	$M_2$ = " Con entrada x:
	\begin{enumerate}
		\item Si x es de la forma $0^{2}$ acepta
		\item  Si no, ejecuta M con entrada w y $\underline{acepta}$ a x si M acepta a w".
	\end{enumerate}
	\item Ejecuta R con entrada $<M_2>$
	\item Si R acepta, $\underline{acepta}$. Si R rechaza, $\underline{rechaza}$.
\end{enumerate}

Como entonces S decide a $A_{TM} \blacksquare$

\subsection{Reducibilidad}

Tenemos dos problemas:
Problema 1 (Entrada: $I_1$ Q: $Q_1$) Problema 2(Entrada: $I_2$ Q: $Q_2$)

Si tenemos un algoritmo $M_1$ para resolver Prob 2, Y un algoritmo $M_2$ que tiene una instancia $I_1$ del Prob 1 y la transforma en una instancia $I_2$ del Prob 2, de tal forma que $I_2$ es una sí-instancia del Prob. 2 si y sólo si $I_1$ es una sí-instancia del Prob 1, entonces

Proponemos $M_3$ que resuelve Prob 1.

$I_1 \rightarrow^{M_2} I_2$ 
Si $M_1$ responde sí, tenemos que $I_2$ es una sí-instancia $\rightarrow$ $I_1$ es una sí-instancia
Si $M_1$ responde no, tenemos que $I_2$ es una no-instancia $\rightarrow$ $I_1$ es una no-instancia

Si Prob. 1 se reduce a Prob. 2 y hay un algoritmo para resolver Prob. 2, entonces hay un algoritmo para resolver el problema 1.

Si sabemos que no hay un algoritmo para resolver Prob. 1 y podemos reducir Prob. 1 a Prob. 2, entonces no hay un algoritmo para resolver al Prob. 2 

Problema 1 $E_{TM}$
Entrada: $<M>$ con M una MT
Pregunta: ¿L(M) = $\emptyset$?

Problema 2 $EQ_{TM} = \{<M_1,M_2>| M_1 \text{ y } M_2 \text{ son MT y } L(M_1) = L(M_2) \}$
Entrada: $<M_1, M_2>$ con $M_1$ y $M_2$ MT
Pregunta: ¿L($M_1$) = L($M_2$)?

Vamos a mostrar que el problema 1 se reduce al problema 2
$<M> \rightarrow^{A} <M, M_2>$ donde $M_2$ es una MT que rechaza a todas sus entradas. Si L(M) = $\emptyset$ entonces $L(M) = L(M_2)$
Si $L(M) \neq \emptyset$ entonces $L(M) \neq L(M_2)$

$\bf{Prop.}$ $EQ_{TM}$ es indecidible.

Dem: Por contradicción. Suponemos que R es una MT que decide a $EQ_{TM}$. Proponemos una MT S.
S = "Con entrada $<M>$ donde M es una MT:
\begin{enumerate}
	\item Ejecuta R con entrada $<M,M_2>$ donde $M_2$ es una MT que rechaza todas las entradas
	\item Si R acepta, $\underline{acepta}$. Si R rechaza, $\underline{rechaza}$.
	Entonces si R acepta a $<M,M_2>$ que dado que $L(M_2) = \emptyset$, entonces $L(M) = \emptyset$. Si R rechaza a $<M, M_2>$ entonces $L(M) \neq \emptyset$ luego, $S$ acepta a $<M>$ si y sólo si $L(M) \neq \emptyset$.
	Por lo tanto $S$ decide a $E_{TM}$!
\end{enumerate}

$\bf{Def.}$ Una función $f: \Sigma^{*} \rightarrow \Sigma^{*}$ es $\underline{computable}$ si existe una MT M que con cualquier entrada $w$ se detiene con una reducción $f(w)$ en su cinta

$\bf{Def.}$ Un lenguaje A es reducible si por funciones (muchas o una) al len. B, $A \leq_{M} B$ si existe una función computable $f_ : \Sigma^{*} \rightarrow \Sigma^{*}$ tal que para cada $w \in \Sigma^{*}$, $w \in A$ si y solo si $f(w) \in B$

$\bf{Teo.}$ Si $A \leq_{M} B$ y B es decidible, entonces A es decidible.

Dem: Sea M un decididor para B y sea f la reducción de A a B. Proponemos a N.
N = "Con entrada w:
\begin{enumerate}
	\item Calcula $f(w)$
	\item Ejecuta M con entrada $f(w)$
	\item Responde lo mismo que M ".
\end{enumerate}

Si $w \in A$, por la def. de reducción, $f(w) \in B$, y por tanto M acepta a $f(w)$ y N acepta a w. Si $w \notin A$, $f(w) \notin B$, y M rechaza a $f(w)$ y N rechaza.
Luego, N decide a A $\blacksquare$

$\bf{Cor}$ Si $A \leq_{M} B$ y A no es decidible, entonces B no es decidible.

$\bf{Prop} $$H_{TM}$ es indecidible.

Dem: Veamos que el problema del paro se reduce al problema de la aceptación $A_{TM} \leq H_{TM}$ 
Proponemos a F tal que
F = "Con entrada $<M,w>$ donde M es una MT:
\begin{enumerate}
	\item Construye la MT M' dado que:
	M' = "Con entrada x:
	\begin{enumerate}
		\item Corre a M con entrada x
		\item Si M acepta, $\underline{acepta}$
		\item Si M rechaza, $\underline{se\ cicla}$
	\end{enumerate}
	\item Devuelve $<M',w>$"
\end{enumerate}

Si $<M, w> \in A_{TM}$, entonces $<M',w> \in H_{TM}$.

Si $<M, w> \notin A_{TM}$, entonces $<M',w> \notin H_{TM} \blacksquare$  

$A \leq_M B$
B decidible entonces A decidible
A indecidible entonces B indecidible

$A_{TM} \leq H_{TM}$

$E_{TM} \leq EQ_{TM}$
$<M> \rightarrow <M,M_2>$, $M_2$ rechaza todas las codificaciones

$<M> \in E_{TM} \leftrightarrow L(M) = \emptyset \leftrightarrow L(M) = L(M_2) \leftrightarrow <M_1,M_2> \in EQ_{TM}$

$E_{TM}$ es indecidible 
$\overline{E_{TM}}$ es indecidible 
$<M, w>$
$M_1$ = "Con entrada x
\begin{enumerate}
	\item Si $x \neq w$, $\underline{rechaza}$
	\item Ejecuta M con entrada w
	\item Si M acepta, $\underline{acepta}$
\end{enumerate}

$L(M_1) = \emptyset \text{si w} \notin L(M) |w| \text{si w} \in L(M)$

$<M, w> \rightarrow <M_1>$

$<M_1,w> \in A_{TM} \leftrightarrow$ M acepta a w $\leftrightarrow L(M_1) \neq \emptyset \leftrightarrow <M_1> \notin E_{TM}$ 

$\bf{Obs}$ L es decidible si y sólo si $\overline{L}$ complemento es decidible.

Dem: Si R decide a L proponemos a S dada por:
S = "Con entrada w
\begin{enumerate}
	\item Ejecuta R con entrada w
	\item Si R acepta, $\underline{rechaza}$ y s R rechaza, $\underline{acepta}$
\end{enumerate}

$\bf{Obs}$ Si $A \leq_{M} B$ entonces $ \overline{A}\leq_{M} \overline{B}$.
Dem: f computable tal que $w \in A$ si y sólo si $f(w) \in B$ luego $e \notin A$ si y sólo si $f(w) \notin B$

$\bf{Obs}$ Si $A \leq_{M} B$ y B es reconocible, entonces A es reconocible
R es un reconocedor $f(w) \in B$ si y sólo si $w \in A$
S = "Con entrada w
\begin{enumerate}
	\item Calcular f(w)
	\item Ejecutar R con entrada f(w)
	\item Responder lo mismo que R"
\end{enumerate}

$S(w) = R(f(w))$


$A_{TM} \leq \overline{E_{TM}} \Rightarrow \overline{A_{TM}} \leq E_{TM}$

$\overline{E_{TM}}$ es reconocible

$A_{TM} \leq_M \overline{E_{TM}}$ ¿$A_{TM} \leq_M E_{TM}$? No

$\overline{A_{TM}} \leq_M \overline{E_{TM}} \Rightarrow \overline{E_{TM}}$ no es reconocible !\\

$\bf{Prop}$ $EQ_{TM}$ no es reconocible ni co-reconocible.

$A_{TM} \leq \overline{EQ_{TM}}$
$A_{TM} \leq EQ_{TM}$
Dem: F = "Con entrada <M,w> donde M es una MT
\begin{enumerate}
	\item Construimos las MT $M_1$ y $M_2$ dadas por 
	$M_1$ = "Con entrada x:
	\begin{enumerate}
		\item $\underline{Rechaza}$"
	\end{enumerate}
	$M_2$ = "Con entrada x:
	\begin{enumerate}
		\item Ejecuta a M con entrada w.
			  Si M acepta, $\underline{acepta}$
	\end{enumerate}
	\item Devuelve $<M_1, M_2>$
\end{enumerate}
Notemos que $L(M_1) = \emptyset$ y $L(M_2) = \Sigma^{*}$ si M acepta a w o $\emptyset$ si M no acepta a w.

Si $<M,w> \in A_{TM}$, entonces $L(M_2) = \Sigma^{*}$ y $<M_1,M_2> \in \overline{EQ_{TM}}$.

Si $<M_1,M_2> \in \overline{EQ_{TM}}$, entonces $L(M_2) \neq L(M_1)$, entonces $L(M_2) = \Sigma^{*}$ y por tanto M acepta a w y $<M,w> \in A_{TM}$

Luego F calcula una reducción $A_{TM} \leq_M \overline{EQ_{TM}}$

Si hacemos que $M_1$ acepte en lugar de rechazar, tenemos que:
Si $<M,w> \in A_{TM}$, entonces $L(M_2) = \Sigma^{*}$ y $<M_1,M_2> \in EQ_{TM}$.

Si $<M_1,M_2> \in EQ_{TM}$, entonces $L(M_2) \neq L(M_1)$, entonces $L(M_2) = \Sigma^{*}$ y por tanto M acepta a w y $<M,w> \in A_{TM}$

\section{Complejidad}

Vamos a trabajar únicamente con máquinas de Turing decidibles

Sea M una MT que se detiene en todas sus entradas. La complejidad (en tiempo) de M es la función $f: \mathds{N} \rightarrow \mathds{N}$ tal que $f(n)$ es el mejor tiempo que puede tardarse M en ejecutarse con una entrada de longitud n. Si $f(n)$ es el tiempo de ejecución de M, diremos que M corre en tiempo $f(n)$ o que M es de tiempo $f(n)$.

Sea $t: \mathds{N} \rightarrow \mathds{R}$ una función. La clase de de complejidad en tiempo TIME(t(n)) es el conjunto de todos los lenguajes decidibles en tiempo $\mathcal{O}(t(n))$ por una MT

$L = \{0^{n}1^{n}\} n \in \mathds{N}$
M = "Con entrada w:
\begin{enumerate}
	\item Recorre la cinta y si encuentra un 1 a la derecha de un 0, $\underline{rechaza}$ ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 y 1 en la cinta 
	\item Recorre la cinta(entrada) y borra el primer 0 y el primer 1. ($\mathcal{O}(n) \cdot \frac{n}{2}$) 
	\item Si sobra algún 0 o algún 1 en la cinta $\underline{rechaza}$. Si no, $\underline{acepta}$". ($\mathcal{O}(n)$)
\end{enumerate}

$M \in TIME(n^2)$ M es de tiempo $\mathcal{O}(n^{2})$
$L \in TIME(t(n))$

$TIME(n) \subseteq TIME(n^2)$


$M_2$ (Máquina de Turing con 2 cintas)= "Con entrada w:
\begin{enumerate}
	\item Recorre la entrada y $\underline{rechaza}$ si hay un 0 a la derecha de 1. ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 y en 1 en la cinta ($\mathcal{O}(\log{n})$)
	\item Revisa si el número de 0 y 1 es par o impar. Si es impar, $\underline{rechaza}$ ($\mathcal{O}(n)$)
	\item Recorre la cinta borrando un 0 si y uno no y un 1 si y uno no, empezando por el primero. ($\mathcal{O}(n)$)
	\item Si hay 0 o 1 en la cinta, $\underline{rechaza}$. Si no, $\underline{acepta}$" ($\mathcal{O}(n)$)
\end{enumerate}

$\mathcal{O}(n) + \mathcal{O}(\log{n}) \cdot 2\cdot \mathcal{O}(n)  + \mathcal{O}(n) = \mathcal{O}(n \log{n})$

$M_2$ corre en tiempo $\mathcal{O}(n \log{n})$ ó $\Theta(n \log{n})$

$L \in TIME(n\log{n})$
$L \in TIME(n^2)$


$M_3$ (Máquina de Turing con 3 cintas)= "Con entrada w:
\begin{enumerate}
	\item Recorre la entrada y copia los 0 en la cinta 2 y los 1 en la cinta 3 ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 en la cinta 2 y 1 en la cinta 3 ($\mathcal{O}(n)$)
	\item Borra un 0 en la cinta 2 y un 1 en la cinta 3. ($\mathcal{O}(1)$)
	\item Si los 0 se acaban antes que los 1, o viceversa, $\underline{rechaza}$. De otro modo $\underline{acepta}$". ($\mathcal{O}(n)$)
\end{enumerate}

$M_3$ corre en tiempo $\mathcal{O}(n)$

$L \in TIME(n \log{n})$ 
Cambiando el modelo $\rightarrow L \in TIME(n)$\\

$\bf{Teo}$ Sea t(n) una función con $t(n) \geq n$
Entonces toda MT multicinta de tiempo t(n) tiene una MT de una sola cinta equivalente y de tiempo $\mathcal{O}(t(n^2))$

Dem: Utilizamos la simulación de una MT multicinta M con una MT de una sola cinta S.
Para simular un paso de M, S recorre la entrada y ubica el símbolo que lee cada cabezal virtual; esto lleva tiempo la longitud de la cadena actualmente en su cinta. Esta longitud es la suma de las longitudes de los contenidos de todas las cintas de M. Cada cinta de M contiene a lo más t(n) símbolos (pues se ejecuta por a lo más tiempo t(n)) En total, este paso se lleva tiempo $k \cdot t(n) \in \mathcal{O}(t(n))$
Después, recorre nuevamente la cinta, actualizando las acciones de M. Quizá, haciendo k shifts en el proceso. Este recorrido junto con los shifts se lleva tiempo $ k \cdot \mathcal{O}(t(n))$ que es $\mathcal{O}(t(n))$. Así, S se tarda $\mathcal{O}(t(n))$ en simular un paso de M, y tiene que simular t(n) pasos, luego el tiempo total es $\mathcal{O}(t(n)^2) \blacksquare$.

N es una MTN t(n) $\rightarrow$ existe M MTD equivalente $\mathcal{O}(2^{t(n)})$

Toda MT multicinta $M_1$ tiene una MT $M_2$ de una cinta tal que si $M_1$ corre en un tiempo t(n), entonces $M_2$ es de tiempo $\mathcal{O}(t(n^2))$\\

$\bf{Def}$ Sea t: $\mathds{N} \rightarrow \mathds{N}$ tal que $t(n) \geq n$ para cada $n \in \mathds{N}$. Decimos que la MTN N corre un tiempo t(n) si t(n) es el máximo número de pasos que debe realizar N para detenerse con una entrada de longitud n. N es un decididor (Todas las ramas terminan).

M simula a N
\begin{enumerate}
	\item cinta w - entrada de N
	\item cinta de trabajo
	\item generar dirección 
\end{enumerate}

$\bf{Teo}$ Si N es una MTN de tiempo t(n) que es un decididor, donde $t(n) \geq n$ p.c. $n \in \mathds{N}$, entonces existe una MTD, D, tal que D es equivalente a N y es de tiempo $2^{\mathcal{O}(t(n))}$.

Dem: Consideremos la simulación de N por una MTD de 3 cintas vista anteriormente. Con una entrada de longitud n, cada rama de la ejecución no determinista de N tiene longitud a lo más t(n).Además cada nodo en el árbol tiene a lo más b hijos. Hay a lo más $b^{t(n)}$ hojas en el árbol y a lo más, el mismo número de vértices internos , i.e. hay $\mathcal{O}(b^{t(n)})$ vértices en el árbol de ejecución de N.
El tiempo que toma a M iniciar en la raíz y simular una rama de la ejecución de N hasta un vértice dado, es a lo más t(n).
Luego, hay $\mathcal{O}(b^{t(n)})$ vértices en el árbol y simular a M para llegar a cada uno de ellos en tiempo t(n), i.e., la simulación completa toma tiempo $t(n) \cdot \mathcal{O}(b^{t(n)}) = \mathcal{O}(b^{t(n)}) = \mathcal{O}(2^{t(n)}) = 2^{\mathcal{O}(t(n))}$. Como M tiene 3 cintas, la podemos simular con una MT de una sola cinta en tiempo $2^{2\mathcal{O}(t(n))} = 2^{\mathcal{O}(2 t(n))} = 2^{\mathcal{O}(t(n))}\blacksquare$\\


$\bf{Def}$ La clase P es la clase de lenguajes decidible por una MTD de una sola cinta en tiempo polinomial, i.e. $P = \bigcup_{t \in \mathds{N}} TIME(n^t)$

$\bf{Def}$ La clase NP es la clase de lenguajes decidible por una MTN de una sola cinta en tiempo polinomial, i.e. $NP = \bigcup_{t \in \mathds{N}} NTIME(n^t)$

$NTIME(t(n))$ = Todos los lenguajes L tales que hay una MTN de tiempo t(n) que decide a L.

NP es Non-deterministic Polynomial, i.e. una MT no determinista lo puede decidir en tiempo Polinomial.

PATH$\{ < D, s, t >$| hay una st-trayectoria (camino que no repite vértices) dirigida en D$\}$

$\bf{Prop}$: PATH $\in$ P

Dem: Proponemos a la MT M dada por 
M = "Con entrada <D, s, t> donde D es una digráfica y s y t son vértices de D:
\begin{enumerate}
	\item Marca S.
	\item Repite hasta que no marquen vértices nuevos.
	\item  Revisa cada flecha de D. Si hay alguna cuya cola esté marcada y cuya cabeza no esté marcada, marca la cabeza.
	\item Si t está marcado, $\underline{acepta}$. Si no, $\underline{rechaza}$
\end{enumerate}

Los pasos 1 y 4 se ejecutan una única vez y toman tiempo $\mathcal{O}(n)$. A lo más, el paso 3 se repite $|V| (es \mathcal{O}(n))$ veces. Cada ejecución de 3 es $\mathcal{O}(n)$. Luego, todas las ejecuciones de 3 se pueden hacer en $\mathcal{O}(n^2)$.

Así, M es de tiempo $\mathcal{O}(n^2) \blacksquare$

RELPRIME = $\{ <x,y> |x$ y $y$ son primos relativos$\}$

$\bf{Prop:}$ RELPRIME $\in$ P

Dem: Proponemos a E una MT dada por 

E = "Con entrada $<x,y>$ donde $x$ y $y$ son enteros positivos
\begin{enumerate}
	\item Repite hasta que $y = 0$
	\item $\  $	Asigna $x \leftarrow x (mod y)$
	\item $\  $	Intercambia $x$ y $y$
	\item Devuelve x
\end{enumerate}

Proponemos a M dada por:

M = "Con entrada $<x,y>$ donde $x$ y $y$ son enteros positivos
\begin{enumerate}
	\item Ejecuta E con entrada $<x,y>$
	\item Si E devuelve 1 $\underline{acepta}$. Si no, $\underline{rechaza}$
\end{enumerate}

Como cada paso individual se puede hacer en tiempo polinomial, basta ver cuantas veces se repiten los pasos 2 y 3. 

Si $\frac{x}{2} \geq y$, $x (\mod y) < y \leq \frac{x}{2}$
Si $\frac{x}{2} \leq y$, $x (\mod y) = x - y < \frac{x}{2}$

Cada dos vueltas del ciclo, el valor de x y el de y disminuyen a la mitad. Luego, estos pasos se realizan $\mathcal{O}(\log(n))$ veces$\blacksquare$

$EQ_{LLC}$ es indecidible.\\

Sí-certificado. Algoritmo para verificar el certificado (simple).

Un $\underline{verificador}$ para el lenguaje A es una MT decididora V tal que $A = \{w | \text{V acepta} <w,c> \text{p.c cadena c}\}$
La complejidad de V se mide en términos de la longitud de w, luego, un verificador polinomial para A es un verificador que corre en tiempo polinomial respecto a $|w|$.\\

Ejemplo:
L = $\{<G>| G \text{es k-coloreable}\}$
V = "Con entrada $<G,c>$ donde G es una gráfica y c es una k-coloración de G:
\begin{enumerate}
	\item Revisa que cada vértice aparezca una única vez en c, si no, $\underline{rechaza}$ $\mathcal{O}(|V|^{2})$
	\item  Para cada arista e de G, verifica si los extremos de e tienen colores distintos. Si no, $\underline{rechaza}$ $\mathcal{O}(|E|)$
	\item Revisa que haya a lo más k-colores en c. Si no, $\underline{rechaza}$. $\mathcal{O}(|V|)$
	\item  $\underline{Acepta}$
\end{enumerate}

El certificado es una cadena, verificador es un algoritmo.

Ejemplos de problemas con sus verificadores:

k-col $<$G, coloración$>$

ciclo hamiltoniano $<$G, ciclo hamiltoniano$>$

graf conexa $<$G, árbol generador$>$

sat $<$ $\phi$,$\tau$(asignación de verdad)$>$\\

$\bf{Teo}$ Un lenguaje L está en NP si y sólo si tiene un verificador polinomial.

$\bf{Def}$ Un verificador para un lenguaje A es una MT decididora tal que $A =\{w | V \text{acepta} <w,c> \text{p.a. cadena c}\}$

HAMPATH = $\{<D,s,t>| D \text{es una digráfica, s y t vértices de D y tales que existe una s-t trayectoria hamiltoniana} \}$

$\bf{Prop.}$ HAMPATH $\in NP$

Dem: Proponemos una MTN N tal que: 

N = "Con entrada $<D,s,t>$ donde D es una digráfica, s,t$\in V_D$:
\begin{enumerate}
	\item Escribe una lista de enteros $p_1,..,p_{|V|}$ cada número en la lista se elige de manera no determinista entre 1 y |V| $\mathcal{O}(|V|)$
	\item Si hay repeticiones en la lista $\underline{rechaza}$ $\mathcal{O}(|V|^{2})$
	\item Revisa si $p_1 = s$ y $p_{|V|}=t$, si no, $\underline{rechaza}$ $\mathcal{O}(|V|)$
	\item Para cada i entre 1 y |V|-1, revisa que $(p_i,p_i+1)$ sea una flecha en D. Si no $\underline{rechaza}$ $\mathcal{O}(|V|^{t})$ $t \in \mathds{N}$
	\item Acepta
\end{enumerate}

N corre en tiempo polinomial respecto a |V|, por lo tanto HAMPATH $\in$ NP $\blacksquare$

$\bf{Teorema}$ Un lenguaje L está en NP si y sólo si tiene un verificador polinomial 

Dem: Si V es un verificador polinomial para L, proponemos la MTN N que decide a L dada por:
Supongamos que V es de tiempo $n^{t}$
N: "Con entrada w de longitud n:
\begin{enumerate}
	\item Elige de manera no determinista una cadena c de longitud a lo más $n^t$
	\item Ejecuta V con entrada $<w,c>$
	\item Si V acepta, $\underline{acepta}$. Si no,  $\underline{rechaza}$ $\mathcal{O}(n^t)$
\end{enumerate}

Si L es decidido por la MTN N y la rama de la ejecución no determinista está codificada por C, entonces proponemos a V dada por:
V="Con entrada $<w,c>$
\begin{enumerate}
	\item Simula a N con entrada w usando cada símbolo de c como la siguiente elección en la ejecución no determinista de N que acepta a w. $\mathcal{O} =$ El tiempo que tarda N en decidir a w
	\item Si esta rama de la ejecución de N acepta, $\underline{acepta}$. Si no, $\underline{rechaza} \blacksquare$ $\mathcal{O}(1)$
\end{enumerate}

$L \in NP$
L = $\{w| \text{V acepta} <w,c> \text{para alguna cadena c}\}$
V verificador polinomial para L:
\begin{enumerate}
	\item "Adivinar" una solución
	\item Verificar que la solución es correcta
\end{enumerate}

Si G es una gráfica, un clan de G es un subconjunto C de V tal que G[c](gráfica inducida) es completa. Un k-clan es un clan de cardinalidad k. El máximo entero k tal que G tiene un k-clan es el número de clan de G $\omega_G$

CLAN= $\{<G,k>| \text{G es una gráfica con un k-clan}\}$

(Mapping reducibility)
Existe una MT que computa f:$ \Sigma^{*} \rightarrow \Sigma^{*}$ en tiempo polinomial, $\mathcal{O}(n^k)$ tal que $A \leq_m B$, $w \in A$ si y sólo si $f(w) \in B$. M decide B en tiempo polinomial.
M se ejecuta con entrada f(w), en |f(w)| en $\mathcal{O}(n^k)$, luego su tiempo de ejecución es $\mathcal{O}(|f(w)|^l) = \mathcal{O}((n^k)^l) = \mathcal{O}((n^{k \cdot l}) $ 
F con entrada w computa f(w) en tiempo $\mathcal{O}(|w|^k) = \mathcal{O}(n^k)$

$\bf{Def.}$ Sean A y B lenguajes. Decimos que A es reducible en tiempo polinomial mediante funciones a B, $A \leq_p B$ si existe una función computable en tiempo polinomial $f: \Sigma^* \rightarrow \Sigma^*$ tal que, para cada $w \in \Sigma^*$ se tiene: $w \in A$ si y sólo si $f(w) \in B$.
Se dice que f es una reducción polinomial de A en B.

$\bf{Prop.}$ Si $A \leq_P B$ y $B \in P$, entonces $A \in P$
Dem. Sea M la MT que decide a B en tiempo polinomial, y sea f la reducción polinomial de A en B. Proponemos a S una MT que decide a A, dada por:
S: "Con entrada w:
\begin{enumerate}
	\item Calcula f(w)
	\item  Ejecuta M con entrada f(w) y responde lo mismo que M".
\end{enumerate}

Para ver que S decide a A, consideremos $w \in A$. Entonces $f(w) \in B$ y por lo tanto M acepta a f(w). Luego, S acepta a w. Recíprocamente si S acepta a w, entonces M acepta a f(w), i.e. $f(w) \in B$ y como f es una reducción, $w \in A$. Se sigue que S decide a A. Claramente el paso 1 se realiza en tiempo polinomial or la definición de reducción polinomial y el paso 2 también, pues la composición de polinomios es un polinomio.
(Si f(w) es $\mathcal{O}(n^k)$ M  con entrada f(w) tarda $\mathcal{O}(n^k)^l =  \mathcal{O}(n^{k \cdot l})$)

Si $A \leq_P B$ y $A \notin P$ entonces $B \notin P$

SAT = $\{<\varphi> | \varphi$ | $\varphi$ es una fórmula booleana satisfacible$\}$

Una literal es una variable proporcional o su negación.

Una clausula es una disyunción con literales.

Una fórmula booleana está en FNC si es una conjunción de disyunciones.

$SAT_{FNC} = \{ <\varphi>| \varphi$ es una función booleana en FNC satisfacible $\}$

$SAT_{FNC} \leq_P SAT$

Una fórmula está en 3-FNC si es una conjunción de clausulas de tamaño 3.

3SAT = $\{<\varphi> | \varphi$ es una fórmula booleana satisfacible en 3-FNC $\}$

CLAN = $\{<G,k>|$ G es una gráfica con un clan de cardinalidad k  $\}$

$\bf{Prop.}$ 3SAT $\leq_P$ CLAN
Modela el problema de la izquierda con el de la derecha. Sea $\varphi \in 3FNC$, entonces $\varphi = \cap_{i=1}^{k} (a_i \cup b_i \cup c)$  ($f(<\varphi>) = <G,k>$) 
Para cada clausula en $\varphi$ creamos 3 vértices en G, etiquetados con las literales correspondientes en la clausula $(V = \cup_{i=1}^{k}\{a_i,b_i,c_i\})$ 
Cualesquiera dos vértices de G son adyacentes, excepto:
\begin{enumerate}
	\item Vértices correspondientes a la misma tripleta (De la misma clausula)
	\item Vértices con etiquetas que generan una contradicción, e.g. $x_i$ y $\overline{x_i}$
\end{enumerate}

Veamos que $<\varphi> \in 3SAT$ si y sólo si $<G,k> \in CLAN$.

Si $<\varphi> \in 3SAT$ existe $\tau$ asignación de verdad que satisface a $\varphi$. Sea $\{x_i\}_{\{i \in 1 ... k\}}$ un conjunto de literañes de $\varphi$ tal que $\tau (x_i) = 1$ y $x_i$ pertenece a la i-ésima cláusula. Notemos que al recibir todas las $x_i$ el valor 1 bajo $\tau$, tenemos que no es posible encontrar a una literal y a su negación en $\tau$. Se sigue que en G los vértices correspondientes a $\{x_i\}_{i=1}^{k}$ es un clan de tamaño k. Luego $<G,k> \in CLAN$

Si $<G,k> \in CLAN$, entonces G tiene un clan de tamaño k, $S \subseteq V$. Por la construcción de G no hay dos vértices de S en la misma tripleta, y no hay dos vértices de S tales que sus etiquetas sean contradictorias, por lo tanto podemos asignar 1 a cada terminal correspondiente a un vértice en S. Si llamamos $\tau$ a alguna asignación obtenida al extender la asignación antes descrita a todas las literales de $\varphi$, entonces $\tau$ satisface a $\varphi$ (pues le asigna el valor 1 al menos una variable en cada clausula).

Así, f es una reducción
$|V| = 3k$
$|E| \cdot \mathcal{O}(k^2)$

STABLE = $\{<G,E> | \text{G es una gráfica con un conjunto independiente de tamaño k}\}$

CLIQUE = Todos son adyacentes dos a dos

$CLIQUE \leq_P STABLE$
$ <G,k> \mapsto <H,l>$
$H = \overline{G}$
$l = k$


$<G,k> \in CLIQUE$, entonces G tiene un clan de tamaño k, digamos S. En $\overline{G}$ S es un conjunto independiente de tamaño k. Si $<\overline{G},k> \in STABLE$ entonces $\overline{G}$ tiene un conjunto independiente de tamaño k y pi tanto $\overline{G} = G$ tiene un clan de tamaño k, entonces $<G,k> \in CLIQUE$

$\bf{Def}$ Sea G una digráfica. Un subconjunto $S\in V$ es \underline{convexo} si todos los vértices de cualquier geodésica (trayectoria de longitud mínima) entre pares de vértices distintos están contenidos en S. Usualmente, por conjunto convexo nos referimos a uno distinto de V.

CONVEX = $\{<G,k>| \text{G tiene un conjunto convexo de tamaño k}\}$

$CLIQUE \leq CONVEX$
$<G,k> \mapsto <H,l>$

H se obtiene de G al añadir dos vértices nuevos, $x$ y $y$, y hacerlos adyacentes a cada vértice en G, pero no entre sí.

Si G tiene un k-clan S, $S \cup \{x\}$ es un clan, y por tanto es un conjunto convexo. Por tanto, H tiene un (k+1)-conjunto convexo

$S \subseteq V_H$ es conexa.

$S \subseteq V_G$

Afirmamos S es un clan. De otro modo, $x \in S$
Si $x \in S$, entonces $y \notin S$. Nuevamente S es un clan, pues de otro modo $y \in S$

Por lo tanto G tiene un k-clan$\blacksquare$

$|V_H| = |V_G| + 2$
$|E_H| = |E_G| + 2|V_G|$

CLIQUE $\leq_P$ CONVEX

DConvex = $\{<D,k>| D \text{es una digráfica con un conjunto convexo de tamaño k}\}$

$\bf{Prop.}$ CLIQUE $\leq$ DConvex

La gráfica será:
\begin{itemize}
	\item Bipartita
	\item Sin flechas simétricas
	\item Con cuello 6 (ciclo más corto será de longitud 6)
\end{itemize}

Dem: 

Gadgets 
Por cada vértice de la gráfica hay un hexágono y para cada arista de la gráfica se unirá el vértice x del primer hexágono al y del segundo hexagono y el x del segundo hexagono al y del primer hexágono.

La estructura de control será una trayectoria dirigida

$|V_G| = 6|V_G| + 4$
$|A_G| = 8|V_G| + 2|E_G| +3$

Obs.
\begin{itemize}
	\item Si $n \in V_G$ y C un convexo de D $|C| \geq 2$, tal que $C \cap V_{Hu} \neq \emptyset$, entonces $V_{Hu} \in C$
	\item Sea C un convexo de $D_1$ $|C| \geq 2$. Si $z_i \in C$, p.a. $i \in \{1...4\}$ entonces $C = V_0$
	\item Sean $u,r\in V_G$ t.q. $d(u,r) \geq 2$, si C es un convexo en D t.q. $V_{Hu} \cap C \neq \emptyset \neq V_{Hu} \cap C$, ent. $C = V_D$
	\item Si S es un clan de G, ent. $C = \cup_{u\in S} Hu$ es un convexo en D. Si G tiene un k-clan, entonces D tiene un 6k conjunto convexo.
\end{itemize}

Un lenguaje A es NP-completo si:
\begin{itemize}
\item $A \in NP$
\item Para cada $B \in NP$, $B \leq_P A$
\end{itemize}

Si hubiera un algoritmo polinomial para resolver A, entonces tenemos un algoritmo polinomial para resolver cualquier problema en NP.

Si L es NP-c y tenemos al lenguaje A t.q. 
\begin{itemize}
	\item $A \in NP$
	\item $L \leq_P A$, entonces A es NP-c
\end{itemize}

$4-col = \{<G> | G \text{es una gráfica 4-coloreable} \}$

$\bf{Prop}$ 4-col $\leq_P$ SAT

$G \mapsto \varphi$

$\varphi$ es satisfacible si y solo si G es 4-coloreable

$x_{v c}$ El vértice v recibe el color c

$C = \{a,b,c,d\}$

$\varphi_{color} = \wedge_{v \in V_G}
(x_{v a} \cap \overline{x_{v b}} \cap \overline{x_{v c}} \cap \overline{x_{v d}}) \cup
(\overline{x_{v a}} \cap x_{v b} \cap \overline{x_{v c}} \cap \overline{x_{v d}}) \cup
(\overline{x_{v a}} \cap \overline{x_{v b}} \cap x_{v c} \cap \overline{x_{v d}}) \cup
(\overline{x_{v a}} \cap \overline{x_{v b}} \cap \overline{x_{v c}} \cap x_{v d})$

$\varphi_{propia} = \wedge_{uv \in E_G}(\neg(x_{u a} \cap x_{\sigma a}) \cap
\neg(x_{u b} \cap x_{v b}) \cap
\neg(x_{u c} \cap x_{v c}) \cap
\neg(x_{u d} \cap x_{v d}))$

$\varphi = \varphi_{color} \cap \varphi_{propia}$

Si G es 4-col, entonces $\varphi$ satisfacible.
$\varphi$ satisfacible, entonces G es 4-col.

k-coloracion se puede reducir a SAT en tiempo lineal

$A$ es NP-completo

$SubsetSum \in NP$

$SubsetSum \leq_P A$

M decide a A en tiempo polinomial

$\bf{Teo}$ Cook-Levin SAT es NP-completo

Dem: Sea $L \in NP$, entonces existe N una MTN que decide a L, el tiempo de ejecución de N es $\mathcal{O}(n^k)$ p.a. $k \in \mathds{Z}^+$

$C = Q \cup \Gamma \cup \{\#\}$

$x_{i,j,s}$ se interpreta como $T_{i,j} = s$

$\varphi_{cell} = \wedge_{1 \leq i, j \leq n^k} [(\vee_{s \in C} x_{i,j,s}) \& (\wedge_{s,t \in C  \ s \neq t}(\overline{x_{i,j,s}} \vee \overline{x_{i,j,t}}))]$ $\mathcal{O}(n^{2k}) \cdot \mathcal{O}(l) \cdot \mathcal{O}(l^2)$

%%%%Ver video para verificar fórmula (Bonita en el Sipser)
$\varphi_{start} = x_{1,1,\#} \& x_{1,2,q_0} \& ... \&$


$\varphi_{accept} = \vee_{1 \leq i, j \leq n^k} x_{i,j,q_a}$

$\delta (q_1, a) = \{(q_1, b, R)\}$
$\delta (q_1, b) = \{(q_1, c, R), (q_1,a,R)\}$

$\varphi_{start} = x_{1,1,\#} \& x_{2,2,a} \& x_{2,3,q_2} \& x_{2,4,q_2}... \&$

$\underline{Afirmacion}$: Si el primer renglón es la configuración inicial y cada ventana es legal, entonces cada renglón de la tabla es una configuración que se sigue de la anterior.

Dem: Si en la ventana no aparecen estados entonces, para que sea legal, el símbolo central es igual arriba y abajo. Si en la posición central superior aparece un estado, las tres posiciones de abajo corresponden a una transición correcta gracias a que la ventana es legal $\blacksquare$

%%%%Ver video para obtener fórmula (Bonita en el Sipser)
$\varphi_{move} = \vee_{1 \leq i < n^k, 1 < j < n^k} ()$

Ventana: Subarreglo de 2x3, determinado por su posición central superior


$\varphi = \varphi_{cell} \& \varphi_{start} \& \varphi_{accept} \& \varphi_{move}$

$\varphi$ es satisfacible si y sólo si existe una ejecución de N que acepta a w

%%%%%Ver fórmula (Bonita en el Sipser)
$\varphi_{accept} = \vee_{}x \mathcal{O}(n^{2k}) \cdot \mathcal{O}(l^6) =  \mathcal{O}(n^{2k}) $

$|\varphi| \in \mathcal{O}(n^{2k})$

\subsection{Espacio}

Sea M una MTD que se detiene con todas sus entradas, la complejidad en espacio de M es la función $f: \mathds{N} \rightarrow \mathds{N}$ donde $f(n)$ es el máximo número de celdas que lee M en una ejecución con una entrada de tamaño n. Si la complejidad en tiempo de M es f decimos que corre en espacio $\mathcal{O}(f(n))$. Se define análogamente la complejidad en espacio para una MTN en la que todas las ramas de su ejecución se detienen con todas las entradas.

$\bf{Proposicion}$: SAT se puede decidir en espacio polinomial

Dem: Sea M una MT tal que 
M = "Con entrada $<\varphi>$ donde $\varphi$ es una fórmula booleana.
\begin{enumerate}
	\item Por cada asignación de verdad de las variables $x_1,...,x_m$ de $\varphi$
	\item Evalúa $\varphi$ en la asignación de verdad
	\item Si en algún momento $\varphi$ se evalúa a 1, acepta. Si no, rechaza. "
\end{enumerate}

$\mathcal{O}(m)$ genera todas las asignaciones de verdad.
$\mathcal{O}(m)$ es $\mathcal{O}(|\varphi|)$

$ALL_{AFN} = \{<A> | \text{A es un AFN y L(A)} = \Sigma^{*}\}$

$\overline{ALL_{AFN}}$
N = "Con entrada $<A>$ donde A es un AFN:
\begin{enumerate}
	\item Marca el estado inicial del AFN
	\item Repite $2^q$ veces donde q es el número de estados de A
	\item De forma no determinista, elige un símbolo de entrada y cambia las posiciones de las marcas en los estados de A para reflejar la transición no determinista, generada por la lectura del símbolo.
	\item \underline{Acepta} si en la etapa 3 en algún punto ninguna marca está en un estado de aceptación, i.e., si N encontró una cadena que A rechace. De otro modo $\underline{rechaza}$"
\end{enumerate}

El número de configuraciones de símbolos marcados es igual a $|2^q| = 2^q$

No se sabe si está en NP o co-NP

Si M corre con espacio f(n) ¿Cómo acotamos su tiempo de ejecución?

M corre en tiempo $2^{\mathcal{O}(f(n))}$

SPACE(foo) = $\{$L | existe una MT que corre en espacio f(n) y decide a L$\}$

NSPACE(f(n)) se realiza con máquinas de turing no deterministas

PSPACE = $\cup_{k \in \mathds{N}} SPACE(n^k)$

NPSPACE = $\cup_{k \in \mathds{N}} NSPACE(n^k)$

¿PSPACE = NPSPACE?

EXPTIME = $\cup_{k \in \mathds{N}} TIME (2^{n^k})$

PSPACE $\subseteq$ EXPTIME

N corre en espacio f(n)

$\bf{Teorema}$ (SAVITCH) Para cualquier función  $f: \mathds{N} \to \mathds{R}$, con $f(n) \geq n$,

$NSPACE(f(n)) \subseteq SPACE(f^2(n))$

Por tanto PSPACE = NPSPACE

Alcanzabilidad: N, $c_1$, $c_2$ configuraciones y $t$ entero positivo.

Q: ¿Se puede alcanzar $c_2$ desde $c_1$ en a lo más t pasos siguiendo las reglas de N?

H $\to$ ALCANZA

N, w

¿N acepta a w?

$C_{start} =$ configuración inicial

$C_{accept} = q_a \sqcup$

ALCANZA($C_{start}, C_{accepr}, t$)

$t = 2^{\mathcal{O}(f(n))}$

$log t = \mathcal{O}(f(n))$

La pila no crece más de log y en cada llamada recursiva se guarda espacio f(n), de ahí que el algoritmo corre en $\mathcal{O}(f^2(n))$


Dem: Sea N una MTN de espacio f(n)

Construimos una MTD M "que simula a N". M usa la subrutina ALCANZA que toma 3 argumentos, dos configuraciones $c_1$ y $c_2$ y un entero positivo t y ALCANZA($c_1,c_2,t$) acepta si N en t pasos puede alcanzar la configuración $c_2$ partiendo de $c_1$. En otro caso rechaza. Para facilitar el análisis supongamos que t es una potencia de 2.

ALCANZA= "Con entrada $c_1, c_2,t$:
\begin{enumerate}
	\item Si t= 1, verifica si $c_1 = c_2$ o si tras un paso en la ejecución de N, $c_1$ alcanza a $c_2$. $\underline{Acepta}$ si se cumple alguna de las dos condiciones y $\underline{rechaza}$ de otro modo
	\item Por cada configuración $c_m$ de N que usa espacio f(n):
	\item   Calcula ALCANZA($c_1,c_m,\frac{t}{2}$)
	\item   Calcula ALCANZA($c_m,c_2,\frac{t}{2}$)
	\item   Si 3 Y 4 aceptan, $\underline{acepta}$
	\item $\underline{Rechaza}$"
\end{enumerate}

Necesitamos modificar N para que tenga una única configuración de aceptación: al aceptar, borra su cinta y regresa el cabezal a la posición más a la izquierda y se mueve a un nuevo estado de aceptación, esta configuración es $C_0$.

Elegimos un entero d tal que N no tenga más de $2^{f(n)}$ es una cota superior por el tiempo de ejecución de cualquier número con cualquier entrada.

Entonces, basta con proponer a M
M="Con entrada w:
\begin{enumerate}
	\item Responde $ALCANZA(C_3, C_0, 2^{f(n)})$
\end{enumerate}

Como ALCANZA resuelve alcanzabilidad, M "simula" a N.

Al llamarse recursivamente, ALCANZA guarda los valores de $C_1$, $C_2$ y t en la pila, para poder restaurarlos al volver de la llamada. Cada nivel de la recursión usa $\mathcal{O}(f(n))$ espacio adicional. Además, cada nivel divide t por 2, es inicialmente  $2^{d f(n)}$, por lo que la profundidad de la recursión es $\mathcal{O}(log2^{d f(n)}) = \mathcal{O}(f(n))$. Por tanto el espacio total que se utiliza es $\mathcal{O}(f^{2}(n))$

¿Cómo obtenemos f(n)?

Probamos $f(n) = 1, f(n)=2, f(n)=3$, .., 

¿Cuándo nos detenemos?

Si $f(n)=i$, ¿podemos alargar alguna configuración de longitud i+1 ?

En cada nivel se guarda $\mathcal{O}(f(n))$

$P \subseteq PSPACE$, $PSPACE \subseteq EXPTIME$

$NP \subseteq NPSPACE$ $P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq EXPTIME$

$\bf{Corolario:}$ PSPACE = NPSACE

Dem: El cuadrado de un polinomio es un polinomio $\blacksquare$

$P \subseteq NP \subseteq PSPACE = NSPACE \subseteq EXPTIME$

$\bf{Def}$ Un lenguaje B es PSPACE-completo si 
\begin{itemize}
	\item B $\in$ PSPACE
	\item Para cada A en PSPACE $A \leq_P B$ (A se puede reducir en tiempo polinomial a B)
\end{itemize}

Forma Normal Prenex (todos sus cuantificadores estén al inicio)

Fórmulas Booleanas Totalmente Cuantificadas en FNP

TQBF =  $\{<\varphi> | \varphi \text{ es una fórmula booleana totalmente cuantificada verdadera} \}$

$\bf{Teo}$ TQBF es PSPACE-completo

Dem:
Proponemos a T una MT tal que 

T: "Con entrada $<\varphi>$, donde $\varphi$ es una f.b.t.c:
\begin{enumerate}
	\item Si $\varphi$ no tiene cuantificadores, entonces solo tienes constantes. Evalúa $\varPhi$ y $\underline{acepta}$ si es verdadera y $\underline{rechaza}$ si no.
	\item Si $\varphi = \exists x \varPsi$ llamamos a T con $\varPsi$ primero sustituyendo cada ocurrencia de x en $\varPsi$ por 0 y después por 1. Si alguno de las dos acepta, $\underline{acepta}$.
	\item Si $\varphi = \forall x \varPsi$, llama a T con $\varPsi$ primero sustituyendo cada ocurrencia de x en $\psi$ por 0 y después por 1. Si las dos aceptan,$\underline{acepta}$, si no $\underline{rechaza}$.
\end{enumerate}

El número de llamadas recursivas es $\mathcal{O}(n)$ donde n es el número de cuantificadores en $\varphi$, y en cada llamada sólo necesitamos usar una cantidad constante de espacio. Por lo tanto T corre en espacio lineal respecto a la longitud de $\varphi$.

Luego TQBF $\in$ PSPACE

Sea A $\in$ TQBF, sea M una MT de espacio polinomial que decide a A. Para cada entrada de A, vamos a construit una f.b.t.c. $\varphi$ tal que $\varphi$ sea verdadera si y sólo si M acepta a w.

Sean $c_1$ y $c_2$ conjuntos de variables que representan configuraciones, es decir, por ejemplo $c_1 = \{x_1 ,..., x_l\}$ donde $l = f(n)$ cada $x_i$ es el contenido de una celda en la configuración de la MT M. Dado un entero t construimos $\varphi_{c_1,c_2,t}$ una fórmula que es verdadera si y sólo si la configuración $c_1$ alcanza a $c_2$ en t pasos o números.

Si $c_0$ es la configuración inicial y $c_d$ es la configuración de aceptación, entonces $\varphi_{c_0,c_d,h}$ es verdadera si y sólo si M acepta a $c_d$ donde $h = 2^{df(n)}$ donde d es una constante suficientemente grande tal que M no corre por más de h pasos. Cuando t=1 $\varphi_{c_0,c_d,h}$ $\varphi$ considera que o bien $c_1 = c_2$, o $c_1$ alarga a $c_2$ en una transición- En el segundo , utilizamos la fórmula del Teorema de Cook para las ventanas suponiendo que $c_1$ y $c_2$ son configuraciones adyacentes.

Si $t > 1$ $\varphi:{c_1,c_2,t} = \exists m_1 [\varphi_{c_1,m_1,\frac{t}{2}} \& \varphi_{m_1,c_2,\frac{t}{2}}]$

En su lugar proponemos

$\varphi:{c_1,c_2,t} = \exists m_1 \forall (c_3,c_4) \in \{(c_1,m_1), (m_1,c_2)\} \varphi_{c_3,c_4,t}$ Gracias al cuantificador universal tenemos los valores

$\varphi_{c_1,m_1,\frac{1}{2}}$ y $\varphi_{m_1,c_2,\frac{1}{2}}$

El tamaño de $\varphi_{c_1,c_2,h}$ con $h = 2^{d(f(n))}$. Por cada llamada recursiva se usa espacio lineal y la profundidad log $2^df(n) \in \mathcal{O}(f(n))$

La longitud de $\varphi_{c_1,c_2,h}$ es $\mathcal{O}(f^2(n))$ Como $f(n) = n^t$ para algún entero k entonces $\mathcal{O}(f^2(n)) = \mathcal{O}(n^{2t})$ que es polinomial.
 
Sea $\varphi = \forall x_1, \exists x_2, \forall x_3, ... Qx_k [x]$ $Q \in \{\exists, \forall\}$

$\varphi_1 = \exists x_1, \forall x_2, \exists x_3 ((x_i \vee x_2) \wedge (x_2 \vee  x_3) \wedge (\overline{x_2} \vee \overline{x_3}) )$

$\varphi_2 = \exists x_1, \forall x_2, \exists x_3 ((x_i \vee x_2) \wedge (x_2 \vee  x_3) \wedge (x_2 \vee \overline{x_3}) )$

FORMULA-GAME = $\{<\varphi>| \text{ El jugador E tiene una estrategia ganadora para el juego asociado a } \varphi\}$

$\bf{Teo}$ FORMULA-GAME es PSPACE-complete

TBQF = $\{<\varphi>| \varphi \text{ es una fórmula boolena totalmente cuantificada en FNP, verdadera }\}$

Dem: Demostraremos que FORMULA-GAME = TQBF

Si $\varphi$ es verdadera, entonces por cada elección que haga A, existe una elección para E que hace a $\varphi$ verdadera. Luego, E tiene una estrategia ganadora. Recíprocamente si E tiene una estrategia ganadora, entonces existe una asignación para las variables cuantificadas existencialmente par cualquier elección de las variables cuantificados universalmente que hacen a $\varphi$ verdadera. Luego FORMULA-GAME $\subseteq$ TQBF $\blacksquare$

Geografía-Generalizado: Se juega sobre una digrpafica D y empezando en un vértice distinguido b. Los jugadores 1 y 2 alternan turnos eligiendo un vértices en la exvecindad del vértice actual. No se pueden repetir vértices y el primer jugador que no puede elegir un vértice pierde.

GG = $\{<D,b> | \text{ El jugador I tiene una estrategia ganadora en GG sobre D empezando en b}\}$

$\bf{Teo}$ GG es PSPACE-completo

M = "Con entrada <D,d> con D una digráfica y b un vértice de D:
\begin{enumerate}
	\item Si b tiene exgrado cero $\underline{rechaza}$ (I no tiene movimientos)
	\item Borra b y todas las flechas incidentes en b para obtener $G_1$
	\item Para cada $v \in V^{+}(b)$ (exvecindad de b), llama recursivamente a M con entrada $<G_1, v>$ 
	\item SI todas las llamadas en 3 aceptan, entonces $\underline{rechaza}$ (II tiene una estrategia ganadora). Si no, II no tiene estrategia ganadora, por lo que I si la tiene, $\underline{acepta}$ "
\end{enumerate}

Notamos que GG es decidido por M. Además, M sólo necesita guardar un vértice en la pila de recursión en casa llamada. Se sigue que M corre en espacio lineal, por tanto, GG $\in$ SPACE

$\varphi = \exists x_1\forall x_2 \exists x_3 ((x_1 \vee x_2) \wedge (x_2 \vee \overline{x_3}) \wedge (\overline{x_2} \vee \overline{x_3}))$

Para cada variable $x_i$, en el orden en el que aparecen cuantificadas en $\varphi$, creamos un "rombo".

Para dos variables consecutivas unimos a sus "rombos" con una flecha del vértice inferior del primero al superior del segundo, por ejemplo si en $\varphi$ aparecen $\forall x: \exists x_{i+1} $ unimos el rombo de $x_i$ con el de $x_{i+1}$.

Para la i-ésima clausula $(x_1 \vee x_e \vee ... \vee x_k )$ creamos la siguiente estructura: Un vértice por cada literal y un vértice adicional que los domina a todos.

Para cada vértice correspondiente a una literal en los gadgets anteriores agregamos una flecha hacia la copia de la literal correspondiente en los "rombos" construidos anteriormente. El vértice b es el vértice superior del primer "rombo" y creamos un nuevo vértices c que tiene flecha hacia el vértice dominante en el gadget de cada clausula y recibe flecha desde el vértice inferior del último "rombo".

$\bf{Obs}$. Una vez que I tira en el vértice superior de un "rombo", los siguientes dos movimientos están forzados y la siguiente decisión la toma II en el vértice superior del siguiente rombo. Esto alternará hasta que se acaben los "rombos".
Podemos suponer que I empieza y termina, y que las decisiones antes descritas son alternadas, quizá agregando cuantificadores a $\varphi$ con fórmulas que no ocurran en $\varPsi$.

Como I toma la decisión sobre el último "rombo", tras dos tiros forzados, II elige sobre que clausula tirar. Sin importar cual elija, si E tiene una estrategia ganadora, podemos garantizar que todas las clausulas son verdaderas, por lo que I puede elegir la literal verdadera en su siguiente tiro y como esa literal se usó en el "rombo" correspondiente II no tiene movimientos.

Si I tiene una estrategia ganadora, entonces por la observación anterior, sin importar que clausula elija II al final del juego, I siempre puede elegir una literal en esa clausula por la que se paso previamente en el camino generado por el juego. Por tanto, para cada decisión de I hacia la izquierda, E elige I como el valor para la variable correspondiente y por cada decisión de I hacia la derecha E elige 0 como el valor de la variable correspondiente. Esto garantiza que cada clausula tiene al menos una literal verdadera. $\blacksquare$ 


\subsection{Espacio sublineal}

Hasta el momento la cantidad de espacio usado $f(n)$ cumplía que $f(n) > n$. Para cada espacio subliminal necesitamos modificar un modelo. Vamos a correr una MT con dos cintas una de sólo-lectura (entrada) y una de lectura-escritura (trabajo). En la cinta de trabajo solo se puede ocupar $\mathcal{O}(logn)$ espacio. El cabezal de la cinta de entrada no puede salir del espacio que ocupa la entrada, por lo que esta MT debe tener algún mecanismo para saber cuando el cabezal de la primera cinta está en la posición más a la izquierda o al final de la entrada.

L = SPACE(logn)

Los lenguajes que pueden ser decididos por una MTD en espacio logarítmico.

NL = NSPACE(logn)

Los transductores son máquinas que tienen una cinta de solo salida y que su fin ultimo es generar una salida a diferencia de las MT cuyo fin es reconocer un lenguaje (aceptar o rechazar)

$\bf{Def}$ Transductor de Espacio Logarítmico.
Es una MT con tres cintas, una será de sólo-lectura (entrada) con la misma restricción de que e cabezal no puede moverse del inicio de la entrada.
Va a tener una cinta de lectura-escritura (trabajo) que tendrá espacio logarítmico.
Y va a tener una cinta de sólo-escritura (salida)

Computa $f:\Sigma^* \to \Sigma^*$ con salida $f(w)$ y siempre que empiece con w en su cinta de entrada, la ejecución sólo usa espacio O(logn) en la cinta de trabajo y termina su ejecución con $f(w)$ en la cinta de salida. Si A y B son lenguajes decimos que A es reducible en espacio logarítmico a B. $A \leq_{L} B$ si hay una función computable $f$, calculada por un transductor de espacio logarítmico tal que $w \in A$ si y sólo si $f(w) \in AS$

Un lenguaje A es NL-completo si
 \begin{itemize}
 	\item $A \in NL$
 	\item Para cada B$ \in$ NL, B$\leq_L$ A
 \end{itemize}

Tenemos al lenguaje $\{0^k 1^k | k \in \mathds{N}\} = A$ $A \in L$

Veamos que tendrá espacio logarítmico:

M = " Con entrada w
\begin{enumerate}
\item Revisa que w sea de la forma 0*1*. De no ser así, $\underline{rechaza}$. $\mathcal{O}(1)$
\item Cuenta los 0 en w y escribe cuántos hay en un contador en la cinta de trabajo. $\mathcal{O}(log n)$
\item Cuenta los 1 en w y escribe cuántos hay en la cinta de trabajo. $\mathcal{O}(log n)$
\item Si los contadores son iguales, $\underline{acepta}$. Si no, $\underline{rechaza}$. $\mathcal{O}(1)$
\end{enumerate}

Una MT que corre en espacio $f(n)$ usa tiempo a lo más $2^{O(f(n))}$  $f(n) \geq n$

Dada una MT de es espacio logarítmico M y una entrada w, una configuración de M sobre w es una elección de un estado contenido de la cinta de trabajo y posiciones de los dos cabezales

Si M corre en espacio $f(n)$ y w es una cadena de longitud de n, entonces M tiene el siguiente número de configuraciones sobre w:

$|Q|= q$ (estados) $|p^k|= g$ (cardinalidad de los símbolos en el alfabeto )

$nqg^{f(n)}f(n) = n2^{\mathcal{O}(f(n))}$

$f(n)\geq log$
$2^{\mathcal{O}(f(n))}$  $2^{\mathcal{O}(log n)}$
$2^{klogn} = 2^{logn^k} = n^k =$ polinomial

$n2^{\mathcal{O}(f(n))}$ podemos elegir una constante suficientemente grande tal que $n2^{\mathcal{O}(f(n))}$ sea $2^{\mathcal{O}(f(n))}$

$g^{(f(n))} \leq 2^k$

Si M corre en espacio logarítmico entonces corre en tiempo polinomial.

En la demostración del teorema de Savich $log(n2^{\mathcal{O}(f(n))}) = log(n) + log2^{\mathcal{O}(f(n))}$
$= logn + \mathcal{O}(f(n)) = \mathcal{O}(f(n))$.

y en cada llamada recursiva sólo necesitamos espacio $\mathcal{O}(f(n))$ para guardar la configuración de M en la pila.

¿NL?

$PATH = \{<D,s,f>| D \text{ es una digráfica con una st-trayectoria}\}$

Eliges un camino de forma no determinista

M = "Con entrada $<D,s,t>$ con D una digráfica, $s,t \in V$:
\begin{enumerate}
	\item Inicializa un contador $c$ en la cantidad de vértices de la digráfica y una variable x en S, en la cinta de trabajo.
	\item Mientras $c > 0$:
	\item   Si $x = t $, $\underline{acepta}$.
	\item   Elige un vértice v de forma no determinista en la exvecindad de x y reemplaza x por v.
	\item   Decrementa $c$ en una unidad.
	\item $\underline{Rechaza}$ "
\end{enumerate}

Espacio: $2logn = \mathcal{O}(logn)$

$\bf{Teo}$ PATH es NL-completo

Dem: Sea $A \in NL$ y supongamos que N es una MTN que decide a $A$. Sea w una cadena. Construyamos una digráfica D tal que cada vértice de D es una configuración de N sobre w, y donde $(c_i,c_j) \in A_D$ si y sólo si hay una transición $w N$ de $c_i$ o $c_j$. Para generar la lista de vértices de D vamos a generar todas las cadenas de longitud a lo más grande de N y vamos a verificar si cada una es o no una configuración válida de N. Si no lo es, continuamos, si sí, la copiamos a la cinta de salida. 

Las flechas se generan análogamente pero probando parejas de configuraciones de N.

El vértice s es la configuración inicial $c_s$ y para t podemos modificar a N como en el teorema de Savitch para que haya una única configuración de aceptación $c_a$.Entonces t es $c_a$. Ya tenemos $<D,s,t>$. Si N acepta a w, entonces alguna rama de N termina un $c_a$. Los nodos de dicha rama conforman una st-trayectoria en D. Recíprocamente, si hay una st-trayectoria en D, entonces hay una sucesión de transiciones de N que empezando en $c_s$ terminan en $c_a$. Luego, alguna rama del árbol de ejecución de N termina en la configuración de aceptación y por lo tanto N acepta a w.

Como en la cinta de trabajo hay a lo más dos configuraciones de N, el espacio utilizado es $\mathcal{O}(logn) \blacksquare$.

$\bf{Teo}$ Si A y B son lenguajes tales que $A \leq_L B$ y $B \in L$ entonces $A \in L$

M = "Con entrada w
\begin{enumerate}
	\item Calcula f(w)
	\item Corre $M_B (f(w))$ y responde lo mismo" 
\end{enumerate}

Dem: Sea $M_A$ el transductor que calcula f(w) con espacio logarítmico y $M_B$ la MT de espacio logarítmico que decide a B, creamos una MT M de espacio logarítmico que haga lo siguiente:
$Simule a M_B$, cada que necesite al siguiente símbolo para continuar su ejecución va a escribir en un contador la posición de la entrada que necesita. En ese punto M guarda el contenido de la cinta de trabajo de $M_B$ y ejecuta a $M_A$ hasta generar la entrada necesaria de f(w). Cada vez que haga esto, borra el trabajo anterior y reinicia la ejecución de $M_A$ desde cero. Para simular a $M_B$ se usa espacio $\mathcal{O}(logn)$ al igual que para simular a $M_A$. Además necesitamos a una celda para guardar el símbolo que está guardando $M_B$ y espacio log. para cada contador. En total, el espacio utilizado es $\mathcal{O}(logn)$

$\bf{Corolario}$ Si un lenguaje NL-Completo está en L, entonces L = NL

$bf{Teo}$ NL = coNL

Dem: PATH es NL-completo $\overline{PATH} \in NL$

%Pseudocódigo completo está en el Sipser%

C= Número de vértices que se alcanzan desde s

Por cada vértice v de D, adivina si v es alcanzado o no por s, y en caso positivo lo verifica. Si la verificación falla rechaza. Si no, aumenta un contador que cuenta cuantos vértices se alcanzan desde s en 1. Cuando ya recorrió todos los vértices compara el contador contra c. Si son distintos, rechaza. Si en algún momento se verifica que s alcanza a t, $\underline{rechaza}$. Si son iguales, entonces M encontró a todos los vértices que se alcanzan desde s y t no es uno de ellos, entonces $\underline{acepta}$.

Necesita una variable para hace la verificación, una para verifica y el contador en espacio log, por lo tanto toma espacio $\mathcal{O}(logn)$

$A_i = \{\text{vértices en D que se alcanzan desde s en una distancia igual a i}\}$ $A_0 = \{s\}$ $c_0 = 1$ 

$A_{i+1}$ usando $A_i$ y $c_i = \{A_i\}$

Verificamos que para cada $v \in V$, si $v \in A_{i+1}$

Para cada vértice v de V adivina si está o no en $A_i$. i sí, lo verifica, aumentando un contador, y busca si (u,v) está en las flechas de D, y aumentamos un contador que cuenta los vértices de $A_{i+1}$ (queremos encontrar i+1). Si $(u,v) \notin A_d$, continua verificando a los demás vértices. Cuando todos los vértices han sido verificados comparamos a d con $c_i$, si son iguales, v no está en $A_{i+1}$




\end{document} 
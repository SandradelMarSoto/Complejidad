\documentclass{homework}

% S\'imbolos
\usepackage{recycle}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}

\usepackage[utf8]{inputenc}


% Figuras
\usepackage{graphicx}
\usepackage{float}

% Gr\'aficas
\usepackage{tikz}

% Estilo Tikz
\tikzstyle{edge}=[shorten <=2pt, shorten >=2pt,
                  >=stealth, line width=1.1pt]
\tikzstyle{vertex}=[circle, fill=white, draw,
                    minimum size=5pt,
                    inner sep=0pt, outer sep=0pt]
\tikzstyle{blackV}=[circle, fill=black, draw,
                    minimum size=5pt,
                    inner sep=0pt, outer sep=0pt]


%Quitamos la sangría
\setlength\parindent{0pt}


\begin{document}
\section*{\LARGE{Notas del Curso de Complejidad 2021-1}}

\section{M\'aquinas de Turing}

\subsection{Introducci\'on}
En 1906 se declara el Problema 10 de Hilbert:
¿Existe un algoritmo que decida si una ecuación diofantina dada (con cualquier mínimo de variables) tiene solución (entera)?

En 1928 se genera el problema de Hilbert-Ackermann :
¿Hay un algoritmo que dado un enunciado, un conjunto de axiomas y un conjunto de reglas de inferencias, decida si el enunciado se puede deducir a partir de los axiomas mediante las reglas de inferencia?

Leibniz propuso el tener "un tipo de álgebra en el que todas las verdades de la razón pudieran reducirse a algún tipo de cálculo"\\

Un problema de decisión P lo podemos pensar como $f : A \rightarrow \{0,1\}$ donde $A$ es el conjunto de instancias (o entradas) de P.
$f^{y}[0]$ conjunto de no-instancias
$f^{y}[1]$ conjunto de sí.instancias

\subsection{M\'aquina de Turing}
$\bf{Def}$ Una Máquina de Turing es una noneta ordenada $M = (Q, \Sigma, \Gamma,\sqcup, \vdash, \delta, q_0, q_a, q_r )$
\begin{itemize}
	\item $Q$ es un conjunto no vacío (de entrada)
	\item $\Sigma$ es un conjunto no vacío (alfabeto de entrada)
	\item $\Gamma$ es un conjunto no vacío (alfabeto de cinta)
	\item $\delta : Q' \times \Gamma \rightarrow Q \time \Gamma \times \{L,R\}$ donde $Q' = Q - \{q_0, q_r\}$
	\item $q_0 \in Q$ (estado inicial)
	\item $q_a \in Q$ (estado aceptación) Estado de paro
	\item $q_r \in Q$ (estado rechazo) Estado de paro
	\item $\sqcup \in \Gamma - \Sigma$ (símbolo en blanco)
	\item $\vdash \in \Gamma - \Sigma$ (marcador o delimitador izquierdo de inicio de cinta)
\end{itemize}

Para cualquier $q \in Q$ existe $p \in Q$ tal que $\delta(q, \vdash) = (p, \vdash, R)$\\

Una configuración de la máquina de Turing se determina por:
\begin{itemize}
	\item Estado $q$
	\item Posición de la cabeza
	\item Contenido de la cinta $uv$
\end{itemize}
La configuración se ve como $uqv$, $q$ es el cabezal que se encuentra en la primera posición de $v$.

Ejemplo: Si $M$ tiene entrada $w$ su posición inicial es $q_0 \vdash w$

La configuración $\alpha$ da lugar a la configuración $\beta$ $\alpha \rightarrow \beta$ y se define como sigue:
\begin{itemize}
	\item $\alpha \rightarrow^{0} \alpha$
	\item Diremos que $\alpha \rightarrow^{n+1} \beta$ si existe una configuración $\Gamma$ tal que $\alpha \rightarrow^{n} \Gamma$ y $\Gamma \rightarrow \beta$
	\item $\alpha \rightarrow^{*} \beta$ si $\alpha \rightarrow^{n} \beta$ para algún $n \in \mathds{N}$
\end{itemize}

Una configuración e aceptación (o rechazo) es cualquiera en la que el estado sea $q_a$ (ó $q_r$). Éstas configuraciones son de paro.\\

Si T es una MT y $w \in \Sigma^{*}$ se dice que T acepta $w$ si $q_0 \rightarrow^{n} xq_ay$ para cadenas $x, y \in \Sigma^{*}$.

El lenguaje de T, L(T) es el conjunto L(T) = $\{x \in \Sigma^{*} | T \text{ acepta a } x\}$.

Si L $\subseteq \Sigma^{*}$ es un lenguaje, se dice que T acepta a L si L(T) = L.

Los lenguajes regulares pueden ser reconocidos por un autómata finito determinista 

$\bf{Algoritmo}$ Algoritmo para convertir de DFA (autómata finito determinista) a TM (máquina de Turing)
\begin{enumerate}
	\item Copiar cada estado
	\item Cambiar cada transición con etiqueta $'x'$ por una con etiqueta $'x/x,R'$
	\item Agregar un estado de aceptación
	\item Para cada estado final en el autómata, agregarle una transición $\sqcup / \sqcup, R$
\end{enumerate}

¿Cómo describimos las máquinas de Turing? Con pseudocódigo
Ejemplo:
Describimos la máquina de Turing que obtiene las potencias de dos como sigue:
M = "Con entrada $\vdash w$:
\begin{enumerate}
	\item Recorre la cinta de izquierda a derecha, tachando un cero no y uno si
	\item Si en 1 la cinta contenía un único cero, $\underline{acepta}$
	\item Si en 1 la cinta contenía más de un creo, y un número impar de ceros, entonces $\underline{rechaza}$
	\item Regresa el cabezal a extremo izquierdo de la cinta
	\item Va a 1"
\end{enumerate}

Las máquinas de Turing pueden computar funciones parciales.

Tenemos $f : D \rightarrow C$  $D \subseteq \Sigma^{*}$ $C \subseteq \Gamma^{*}$.

$\bf{Def.}$ Sea R una MT, $k$ un natural y $f$ una función parcial sobre $(\Sigma^{*})^{k}$ con valor en $\Gamma^{*}$. Decimos que T computa a $f$ si para cada $(x_1, ..., x_k)$ en el dominio de $f$, 
$q_0 \vdash x_1 \sqcup x_2 \sqcup ... \sqcup x_k \rightarrow^{k} q_0 \vdash f(x_1, ..., x_k)$
y ninguna otra entrada que sea una $k$-ada de cadenas es aceptada por T. 

Una función parcial $f: (\Sigma^{*})^{k} \rightarrow \Gamma^{*}$ es Turing-computable (computable) si hay una máquina de Turing que la computa.

Al fijar el contradominio y la aridad de la función, entonces una MT calcula una única función parcial.\\

Una tercera opción del cabezal de la MT es quedarse en su lugar después de hacer algo (S). 
$\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,R,S\}$.

$M_1$ tiene "la opción" $S$
$M_2$ no tiene "la opción" $S$ pero reconoce el mismo lenguaje que $M_1$ o computa la misma función.

Simulo una máquina de Turing que tiene la opción S con una máquina de Turing que no la tiene al poner un estado adicional, donde en las transiciones se escribe lo mismo que lea y se mueva a la derecha, luego se escriba lo mismo que lea y se mueva a la izquierda.\\

Algunas MT útiles que regresan el cabezal a donde estaba originalmente:
\begin{itemize}
	\item NB (Next Blank)
	\item PB (Previous Blank)
	\item Copy ($\vdash x \rightarrow x \sqcup x$)
	\item Insert($\sigma$)
	\item "Borrar la cinta" (Ponemos un delimitador derecho y borramos todo a su izquierda)
	\item Compare ($\vdash x \sqcup y$ acepta si $x=y$ o rechaza si $x \neq y$)
	\item R (Reverse)
\end{itemize}
Copy $\rightarrow$ NB $\rightarrow$ R $\rightarrow$ PB $\rightarrow$ Equal (Esta máquina de Turing reconoce palíndromos)


\subsection{M\'aquinas de Turing multicintas}
Una MT multicinta es como una MT pero tiene $k$ cintas de memoria. Su definición solo difiere respecto a una MT usual en la función de transición
$\delta : Q \times \Gamma^{k} \rightarrow Q \times \Gamma^{k} \times \{L, R, S\}^{k}$.
$\delta(q_1, a_1,...,a_k) = (q_1,b_1,...,b_k, D_1,...,D_k)$ $D_i \in \{L,R,S\}$.

Las máquinas de Turing multicinta no tienen más poder que las de una cinta.
Para simularlas en una máquina de Turing de una cinta podemos usar bloques como letras de alfabeto y manejamos la posición del cabezal como un puntito en las distintas letras. Le hace una pasada para ver los cabezales y luego realiza otra para hacer las transiciones. La memoria está en la estructura de los estados (el control finito).
Otra manera es que los espacios pares simulen una cinta y los impares otra (es trivial generalizarlo a $k$). Pero usaremos la siguiente:

$\bf{Teorema}$ Toda MT multicinta tiene una MT de una sola cinta equivalente.

Dem: Construimos, dada una MT multicinta M a la MT de una sola cinta S t.q. tiene los contenidos de las cintas de M en su cinta, separados por un símbolo especial $\#$, y usando versiones especiales de cada símbolo en $\Gamma_M$ para denotar donde están los cabezales $\dot{o}$

S = Con entrada $w_1,...,w_n$
\begin{enumerate}
	\item Poner su cinta en el formato que representa las k cintas. La cinta formateada se ve como $| \vdash | w_1 | ... | w_n | \# | \sqcup | \# | \sqcup | ...|$.
	\item Para simular un movimiento, S recorre la cinta desde $\vdash$  donde hasta el último $\#$, para determinar los símbolos que están leyendo los k cabezales. Después S hace una segunda pasada para actualizar las cintas de acuerdo a la función de transición de M.
	\item Si en cualquier punto, S mueve alguna de las cabezas virtuales hacia la almohadilla ($\#$) de la derecha, en M entonces el cabezal correspondiente se movió a un espacio en blanco. Luego, basta con que se inserte un símbolo blanco en esa posición.
\end{enumerate}


$\bf{Corolario}$ Si L es un lenguaje, entonces L es Turing-reconocible si y sólo si L es reconocido por alguna MT multicinta.

Dem: Toda MT es una MT multicinta.

La otra implicación es el teorema anterior $\blacksquare$

\subsection{M\'aquinas de Turing no deterministas}

Se diferencian de las deterministas está en que tenemos una nueva función de transición:

$\delta : Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R, S\})$

Ya no es un algoritmo, sino que ahora la máquina “adivina” qué transición tomar para llegar al resultado.
Se dice que acepta si al menos un camino lleva a aceptación.
Se parecen a los autómatas no-deterministas.
No son implementables en la vida real.
Son equivalentes a una MT (usando una MT que haga BFS exhaustivo sobre el árbol de posibles configuraciones)
Es importante pensar en términos de que la máquina “adivina” la respuesta correcta (SOLO si existe).
Toda MT es MTN.

Ejemplo: Un número en unario ¿Es compuesto?
Aplica la siguiente combinación de MTs NB $\rightarrow$ G (Guess) $\rightarrow$ NB $\rightarrow$ G $\rightarrow$ PB $\rightarrow$ M (Multiply) $\rightarrow$ PB $\rightarrow$ Equal

¿Para qué sirven las MTN?
Estas máquinas teóricas realizan búsquedas exhaustivas “rápidamente”
Resuelven problemas lentos muy rápido.
“Si tuviéramos una MTN, podríamos resolver un montón de problemas que nos causan dolores de cabeza en la vida real”
Como por ejemplo factorización de números y polinomios, agente viajero, SAT, etc.\\


$\bf{Teorema}$ Toda MTN tiene una MTD equivalente.

Dem: Sea N una MTN, proponemos a M una MTD de 3 cintas.
\begin{itemize}
	\item En la primera cinta está la entrada y nunca se modifica.
	\item La segunda cinta es una copia de la cinta de N y se usa para simular a N
	\item La tercera cinta contiene las direcciones de los nodos del árbol de ejecución de N codificadas con $\Sigma = \{1, ..., b\}$ Existen direcciones inválidas.
\end{itemize}

M = "con entrada $w$
\begin{enumerate}
	\item Copia la cinta 1 a la 2
	\item Usa a la cinta 2 para simular a N con entrada $w$ en una rama de su cómputo no determinista.
	Antes de cada transición, consulta la cinta 3 para determinar que decisión tomar entre las distintas posibilidades no deterministas. Si no hay más símbolos en la cinta 3 o se llega a una dirección inválida, aborta y va a 3. Si encuentra una configuración de rechazo va a 3. Si encuentra una configuración de aceptación, $\underline{acepta}$
	\item Reemplaza la cadena en la cinta 3 por la siguiente en el orden canónico de $\{1,..,b\}^{*}$
	\item Va a 1"
\end{enumerate}

Si una MTN M se ejecuta hay 3 posibilidades:
\begin{enumerate}
	\item acepta Configuración de paro
	\item rechaza Configuración de paro
	\item se cicla
\end{enumerate}

$\bf{Corolario}$ Un lenguaje es reconocible si y sólo si alguna MTN lo reconoce.

Una MT que no se cicla es un decididor.

Un lenguaje L es Turing-decidible si existe un decididor que lo reconoce.

$\bf{Corolario}$ Un lenguaje es decidible si  sólo si alguna MTN lo decide.

Dem. La ida es trivial.
Para el regreso notemos que cada longitud de cadena es un nivel del árbol, así que mantenemos un booleano que es v si todas las ejecuciones han terminado (en la longitud actual) f e.o.c.
Cuando acaben las cadenas de longitud k, rechazamos si el booleano es v. En otro caso, vamos a la longitud k+1.

\subsection{Enumeradores}

Sea E una MT con $k$ cintas $k \in \mathds{Z}$ y sea $L \subseteq \Sigma^{*}$. Decimos que E $\underline{enumera}$ a L si:
\begin{enumerate}
	\item El cabezal de la primera cinta nunca se mueve a la izquierda, nunca escribe un espacio en blanco y nunca modifica un símbolo que ya escribió.
	\item Para cualquier $x \in L$ hay algún punto de la operación de E en la que la cinta 1 contiene $x_1 \# x_2 \# ... \# x_n \# x$ donde $x_i \in L$ p.c $1 \leq i \leq n$ y $x_1,...,x_n,x$ son todas distintas.
	Si L es finito no se imprimen símbolos después de la última $\#$.
\end{enumerate}

El lenguaje de E, es L, i.e. L(E) = L.\\

$\bf{Teorema}$: Sea $L \subseteq \Sigma^{*}$ un lenguaje. Entonces L es reconocible si y sólo si es enumerado por algún enumerador; además $L$ es decidible si y sólo si es enumerado en orden canónico por algún enumerador.

Demostración: Supongamos primero que L es decidible y sea M una MT que lo decide. Proponemos a E dado por 

E ="Ignora la entrada
\begin{enumerate}
	\item Genera la siguiente cadena $w$ en orden canónico de $\Sigma^{*}$
	\item Ejecuta M con entrada $w$ e imprime a $w$ si M acepta".
\end{enumerate}

Como M es un decididor para L, E va a recorrer todas las cadenas en $\Sigma^{*}$ y, en orden canónico, va a imprimir solamente las que están en L.

Supongamos que L es reconocido por M. Proponemos al enumerador E dado por:
E ="Ignora la entrada
\begin{enumerate}
	\item Para cada $i \in \mathds{N}$
	\item Genera la siguiente cadena si en orden canónico y le agrega a la lista $s_0, s_1,...,s_i$
	\item Ejecuta M por $i$ pasos con cada una de las entradas $s_0$ hasta $s_i$
	\item Si M acepta alguna de las entradas y no la había aceptado en una ejecución anterior, la imprime."
\end{enumerate}

Si tenemos $s_i$ y $s_k$ tal que $i < k$, 

Supongamos que E enumera a L. Proponemos a M para recorrer a L dado por:
M="Con entrada $w$:
\begin{enumerate}
	\item Ejecuta E. Cada vez que se imprima una cadena, la compara con $w$.
	\item Si $w$ se imprime en algún momento $\underline{acepta}$."
\end{enumerate}

Supongamos que E enumera a L en orden canónico, Proponemos a M dado por
M="Con entrada $w$:
\begin{enumerate}
	\item Ejecuta E. Cada vez que se imprima una cadena, la compara con $w$.
	\item Si $w$ se imprime en algún momento $\underline{acepta}$.
	\item Si la cadena impresa por $E$ supera a $w$ en orden canónico, $\underline{rechaza}$."$\blacksquare$
\end{enumerate}


\subsection{T\'esis Church-Turing}
Turing, Church, Goëdel et al formalizaron el concepto de algoritmo.

Los algoritmos desde el punto de vista intuitivo son equivalentes a las Máquinas de Turing.

Ejemplo:
I : G es gráfica

Q: ¿Es G conexa?

M= "Con entrada $<G>$ con $G$ una gráfica:
\begin{enumerate}
	\item Elige el primer vértice de $G$ y lo marca.
	\item Repite el siguiente paso hasta que no se marquen vértices nuevos.
	\item Para cada vértice en $G$, éste es marcado si es adyacente a algún vértice marcado.
	\item Revisa si todos los vértices están marcados. En tal caso $\underline{acepta}$, si no $\underline{rechaza}$".
\end{enumerate}

M decide A 

\subsection{Máquina Universal de Turing }

U: "Con entrada $<M,w>$ con $M$ una $MT$
 \begin{enumerate}
 	\item Simula a M con entrada a $w$
 	\item $\underline{Acepta}$ si M acepta, $\underline{rechaza}$ si M rechaza.
 \end{enumerate}

\section{Problema de aceptaci\'on}

$A_{AFD} = \{<A,w> | \text{El AFD A acepta a la cadena w}\}$

Problema $A_{AFD}$

I: Un AFD A y una cadena $w$

Q: ¿A acepta a $w$?\\

$\bf{Prop}$: $A_{AFD}$ es decidible.

Dem: Proponemos una MT $M$ que decida a $A_{AFD}$

$M$ = Con entrada $<A,w>$ con a un AFD y w una cadena:
\begin{enumerate}
	\item Simula A con entrada w.
	\item Si la simulación termina en un estado de aceptación, $\underline{acepta}$. Si no, $\underline{rechaza} \blacksquare$
\end{enumerate}

$\bf{Prop}$: $A_{AFN}$ es decidible

Dem: Proponemos una MTD N que decida a $A_{AFN}$

$N$ = "Con entrada $<B, w>$ con B un AFN y w una cadena:
\begin{enumerate}
	\item Construye una AFD A equivalente a B.
	\item Ejecuta M con entrada w.
	\item $\underline{Acepta}$ si M acepta y $\underline{rechaza}$ si M rechaza ".
\end{enumerate}

$A_{REX} = \{<R,w> | \text{R es una expresion regular que genera a w} \}$

$\bf{Prop}$: $A_{REX}$ es decidible

Dem: P = "Con entrada $<R, w >$ donde R es una regex y w una cadena:
\begin{enumerate}
	\item Construye un AFN A equivalente a R.
	\item Ejecuta N con entrada $<A,w>$
	\item Responde lo mismo que N".
\end{enumerate}


$E_{AFD}  = \{<A> | \text{A es un AFD con L(A)}=\emptyset\}$ 

$\bf{Prop}$: $E_{AFD}$ es decidible

Dem: T = "Con entrada $<A>$ donde A es un AFD:
\begin{enumerate}
	\item Marca el estado inicial de A.
	\item Repite hasta que no se marquen estados nuevos
	\item Marca todos los estados que tengan transición desde un estado marcado.
	\item  Si algún estado de aceptación está marcado, $\underline{rechaza}$. Si no, $\underline{acepta}$.
\end{enumerate}

$EQ_{AFD}  = \{<A,B> | \text{A y B son AFD tales que L(A)=L(B)}\}$ 

$\bf{Prop}$: $C, L(C) = L(A)\triangle L(B)$

Dem: F = "Con entrada $<A.B>$ donde A y B es un AFD:
\begin{enumerate}
	\item Construye a C tal que $L(C)=L(A)\triangle L(B)$
	\item Ejecuta a $T$ con entrada C
	\item  Si T acepta, $\underline{acepta}$. Si no, $\underline{rechaza} \blacksquare$.
\end{enumerate}


Función característica:
El conjunto $S \subseteq A$ $\chi_{S} : A \rightarrow \{0, 1\}$
$\chi_{S}(a) =$ 1 si $a \in S$ 0 si $a \notin S$

$\omega = \{0,1,2,3,...\} = \mathds{N}$
$(0,1,0,1,..)$ sería el conjunto de los impares.

$\mathcal{P}(\mathds{N}) \sim^{\mathds{N}} 2 = \{f: \mathds{N} \rightarrow \{0,1\}$

$\varphi : P(\mathds{N}) \rightarrow^{\mathds{N}} 2$
$A \mapsto \chi_{A}$
$\psi : 2 \rightarrow P(\mathds{N})$
$f \mapsto \{i \in \mathds{N} | f(i) = 1\}$

$\psi \cdot \varphi = 1_{P(\mathds{N})}$
$\varphi \cdot \psi = 1_{P(\mathds{N})}$

¿La potencia de los naturales es biyectable con las sucesiones binarias? $\mathds{N} \sim \mathcal{P}(\mathds{N})$
¿Los naturales y la potencia de los naturales no son biyectables?
$\mathds{N} \sim \mathds{N}_2$

Si fueran biyectables podrías tener:
$f: \mathds{N} \rightarrow^{\mathds{N}} 2$
Si f fuera suprayectiva entonces toda sucesión binaria aparecería en la lista (sería imagen de alguien).

$g: \mathds{N} \rightarrow 2$
$g(i) = 1 - f_{i}(i)$
$g = (1,0,1,1,...)$

Podemos llegar a contradicción porque:
$\exists n \in \mathds{N}$
$f_{n}(n) \not= g(n) = 1 - f_{n}(n) $!
Por lo tanto,
$\mathds{N} \nsim \mathcal{P}(\mathds{N})$
$\mathds{N} \nsim \mathds{N}_2$

"Nadie podrá expulsarnos de paraíso que Cantor ha creado"-Hilbert.\\

$\bf{Prop.}$ Existen lenguajes no reconocibles.

Dem: 
Si $\Sigma$ es contable, entonces $\Sigma^{*}$ es numerable.
Sea $\mathcal{M} = \{<M> | M es una MT\} \subset Sigma^{*}$
$|\mathcal{M} \leq \aleph_{0}$

Si $\mathcal{L}L$ es el conjunto de todos los lenguajes sobre el alfabeto $\Sigma$, afirmamos que $|\mathcal{L}| = |\mathds{N}_2|$

Por tanto, $|\mathcal{M}|< |\mathcal{L}|$
Es decir hay más lenguajes que MT. Así, debe haber lenguajes no reconocibles por MT alguna.

$\varphi : \mathcal{L} \rightarrow \mathds{N}_2$
Sea $S_0, S_1, S_2, ...$ el orden canónico de $Sigma^{*}$, y sea $\mathcal{L}$ un lenguaje sobre $Sigma^{*}$ $\blacksquare$\\

¿En general $S \sim P(S)$? $\underline{No}$

Sea $f: S \rightarrow P(S)$. Veamos que f no es suprayectiva. Proponemos $T = \{s \in S | s \notin f(s)\}$
Si $s \in T$ entonces $s \notin f(s)$ ($T \cup (S-T) = S$)
Si $s \notin T$ entonces $s \in f(s)$
Por tanto $T \neq f(s)$
$T \notin Im(f)\blacksquare$\\


$A,E,EQ$
$A_{TM} = \{<M \omega> | \text{M es una MT que acepta a la cadena} \omega\}$

$\bf{Obs}$. $A_{TM}$ es reconocible.
	U = Con entrada $<M, w>$ donde M es una MT
\begin{enumerate}
	\item Simula a M con entrada $w$
	\item Si M acepta, $\underline{acepta}$, si M rechaza, $\underline{rechaza}$
\end{enumerate}

$\bf{Prop}$. $A_{TM}$ no es decidible
Dem. Supongamos que sí, y sea R un decididor de $A_{TM}$
$R(<M,w>) = \{ \underline{acepta} \text{si M acepta a w}, \underline{rechaza} \text{si M rechaza a w}\}$
Construimos una MT D que usa a R como subrutina
D = "Con entrada $<M>$ dada $M$ es una $MT$:
\begin{enumerate}
	\item Ejecuta R con entrada $<M, <M>>$
	\item Si R acepta, $\underline{rechaza}$; si R rechaza, $\underline{acepta}$"
\end{enumerate}
$D(<M>) = \{ \underline{acepta} \text{si M no acepta a }<M>; \underline{rechaza} \text{si M acepta a }<M>\}$

$D(<D>) = \{ \underline{acepta} \text{si D rechaza a }<D>; \underline{rechaza} \text{si D acepta a }<D>\}$!
D $\underline{acepta}$ a D si y sólo si D $\underline{rechaza}$ a D! $\blacksquare$\\

$\bf{Def.}$: Un lenguaje L sobre $\Sigma$ es $\underline{co-reconocible}$ si $\Sigma(\Sigma^{*} - L)$ es reconocible.

$\bf{Prop.}$ Un lenguaje es decidible si y sólo si es reconocible y co-reconocible.

Dem: Sea A un lenguaje. Si A es decidible, entonces es reconocible. Sea M un decididor para A.
M = "Con entrada $w$:
\begin{enumerate}
	\item Ejecuta M con entrada $w$
	\item Si M acepta, $\underline{rechaza}$
	Si M rechaza, $\underline{acepta}$
\end{enumerate}
L(M')= A
Si A es reconocible y co-reconocible.
Proponemos una MT M que decide a A que usa a $M_1$ y $M_2$ que reconocen a A y $\barwedge{A}$ respectivamente.
M = "Con entrada w:
\begin{enumerate}
	\item Simula en paralelo a $M_1$ y $M_2$ con entrada w
	\item Si $M_1$ acepta, $\underline{acepta}$
	\item Si $M_2$ acepta, $\underline{rechaza} \blacksquare$\\
\end{enumerate}

$\bf{Cor}$: El complemento de $A_{TM}$ no es reconocible.

Dem: $A_{TM}$ es reconocible. Si su complemento fuera reconocible, entonces $A_{TM}$ sería decidible pero no lo es $\blacksquare$\\


$H_{TM} = \{<M,w> | \text{M es una MT y M se detiene con entrada w}\}$

$\bf{Prop}$: $H_{TM}$ es indecible

Dem: Supongamos que R decide $H_{TM}$
Proponemos la MT S, dada por:
S = " Con entrada $<M,w>$, donde M es una MT:
\begin{enumerate}
	\item Ejecuta a R con entrada <M,w>
	\item Si R rechaza, $\underline{rechaza}$
	\item Simula a M con entrada w
	\item Si M acepta, $\underline{acepta}$, si no, $\underline{rechaza}$"
\end{enumerate}
Claramente, S decide a $A_{TM}$! $\blacksquare$


$E_{TM} = \{<M> | L(M) = \emptyset\}$

 $\bf{Prop}$ $E_{TM}$ no es decidible.
 
 Dem. Por contradicción. Supongamos que sí es decidible y sea R un decididor para $E_{TM}$. Construimos a S un decididor para $A_{TM}$ dado por:
 S : "Con entrada $<M,w>$ donde M es una MT:
 \begin{enumerate}
 	\item Construye a la MT $M_1$ dada por:
 	$M_1$ = "Con entrada x:
 	\begin{enumerate}
 		\item Si $x \neq w$, rechaza
 		\item  Si $x = w$, corre a M con entrada w y acepta si M lo hace".
 	\end{enumerate}
 	\item Ejecuta R con entrada $<M_1>$
 	\item Si R acepta, $\underline{rechaza}$. Si R rechaza, $\underline{acepta}$".
 \end{enumerate}

El lenguaje de $M_1$ es $|w|$ o $\emptyset$ dependiendo de si M acepta o no a w respectivamente. Por tanto, S es un decididor para $A_{TM} \blacksquare$


Entonces $E_{TM}$ no es decidible

$REG_{TM} = \{<M> | M \text{es una Mt y L(M) es regular}\}$

$\bf{Prop.}$ $REG_{TM}$ es indecidible

Dem: Por contradicción. Sea R un decididor para $REG_{TM}$
Proponemos la MT S dada por:
S = " Con entrada $<M,w>$, donde M es una MT:
\begin{enumerate}
	\item Construye a la MT $M_2$ dada por:
	$M_2$ = " Con entrada x:
	\begin{enumerate}
		\item Si x es de la forma $0^{2}$ acepta
		\item  Si no, ejecuta M con entrada w y $\underline{acepta}$ a x si M acepta a w".
	\end{enumerate}
	\item Ejecuta R con entrada $<M_2>$
	\item Si R acepta, $\underline{acepta}$. Si R rechaza, $\underline{rechaza}$.
\end{enumerate}

Como entonces S decide a $A_{TM} \blacksquare$

\subsection{Reducibilidad}

Tenemos dos problemas:
Problema 1 (Entrada: $I_1$ Q: $Q_1$) Problema 2(Entrada: $I_2$ Q: $Q_2$)

Si tenemos un algoritmo $M_1$ para resolver Prob 2, Y un algoritmo $M_2$ que tiene una instancia $I_1$ del Prob 1 y la transforma en una instancia $I_2$ del Prob 2, de tal forma que $I_2$ es una sí-instancia del Prob. 2 si y sólo si $I_1$ es una sí-instancia del Prob 1, entonces

Proponemos $M_3$ que resuelve Prob 1.

$I_1 \rightarrow^{M_2} I_2$ 
Si $M_1$ responde sí, tenemos que $I_2$ es una sí-instancia $\rightarrow$ $I_1$ es una sí-instancia
Si $M_1$ responde no, tenemos que $I_2$ es una no-instancia $\rightarrow$ $I_1$ es una no-instancia

Si Prob. 1 se reduce a Prob. 2 y hay un algoritmo para resolver Prob. 2, entonces hay un algoritmo para resolver el problema 1.

Si sabemos que no hay un algoritmo para resolver Prob. 1 y podemos reducir Prob. 1 a Prob. 2, entonces no hay un algoritmo para resolver al Prob. 2 

Problema 1 $E_{TM}$
Entrada: $<M>$ con M una MT
Pregunta: ¿L(M) = $\emptyset$?

Problema 2 $EQ_{TM} = \{<M_1,M_2>| M_1 \text{ y } M_2 \text{ son MT y } L(M_1) = L(M_2) \}$
Entrada: $<M_1, M_2>$ con $M_1$ y $M_2$ MT
Pregunta: ¿L($M_1$) = L($M_2$)?

Vamos a mostrar que el problema 1 se reduce al problema 2
$<M> \rightarrow^{A} <M, M_2>$ donde $M_2$ es una MT que rechaza a todas sus entradas. Si L(M) = $\emptyset$ entonces $L(M) = L(M_2)$
Si $L(M) \neq \emptyset$ entonces $L(M) \neq L(M_2)$

$\bf{Prop.}$ $EQ_{TM}$ es indecidible.

Dem: Por contradicción. Suponemos que R es una MT que decide a $EQ_{TM}$. Proponemos una MT S.
S = "Con entrada $<M>$ donde M es una MT:
\begin{enumerate}
	\item Ejecuta R con entrada $<M,M_2>$ donde $M_2$ es una MT que rechaza todas las entradas
	\item Si R acepta, $\underline{acepta}$. Si R rechaza, $\underline{rechaza}$.
	Entonces si R acepta a $<M,M_2>$ que dado que $L(M_2) = \emptyset$, entonces $L(M) = \emptyset$. Si R rechaza a $<M, M_2>$ entonces $L(M) \neq \emptyset$ luego, $S$ acepta a $<M>$ si y sólo si $L(M) \neq \emptyset$.
	Por lo tanto $S$ decide a $E_{TM}$!
\end{enumerate}

$\bf{Def.}$ Una función $f: \Sigma^{*} \rightarrow \Sigma^{*}$ es $\underline{computable}$ si existe una MT M que con cualquier entrada $w$ se detiene con una reducción $f(w)$ en su cinta

$\bf{Def.}$ Un lenguaje A es reducible si por funciones (muchas o una) al len. B, $A \leq_{M} B$ si existe una función computable $f_ : \Sigma^{*} \rightarrow \Sigma^{*}$ tal que para cada $w \in \Sigma^{*}$, $w \in A$ si y solo si $f(w) \in B$

$\bf{Teo.}$ Si $A \leq_{M} B$ y B es decidible, entonces A es decidible.

Dem: Sea M un decididor para B y sea f la reducción de A a B. Proponemos a N.
N = "Con entrada w:
\begin{enumerate}
	\item Calcula $f(w)$
	\item Ejecuta M con entrada $f(w)$
	\item Responde lo mismo que M ".
\end{enumerate}

Si $w \in A$, por la def. de reducción, $f(w) \in B$, y por tanto M acepta a $f(w)$ y N acepta a w. Si $w \notin A$, $f(w) \notin B$, y M rechaza a $f(w)$ y N rechaza.
Luego, N decide a A $\blacksquare$

$\bf{Cor}$ Si $A \leq_{M} B$ y A no es decidible, entonces B no es decidible.

$\bf{Prop} $$H_{TM}$ es indecidible.

Dem: Veamos que el problema del paro se reduce al problema de la aceptación $A_{TM} \leq H_{TM}$ 
Proponemos a F tal que
F = "Con entrada $<M,w>$ donde M es una MT:
\begin{enumerate}
	\item Construye la MT M' dado que:
	M' = "Con entrada x:
	\begin{enumerate}
		\item Corre a M con entrada x
		\item Si M acepta, $\underline{acepta}$
		\item Si M rechaza, $\underline{se\ cicla}$
	\end{enumerate}
	\item Devuelve $<M',w>$"
\end{enumerate}

Si $<M, w> \in A_{TM}$, entonces $<M',w> \in H_{TM}$.

Si $<M, w> \notin A_{TM}$, entonces $<M',w> \notin H_{TM} \blacksquare$  

$A \leq_M B$
B decidible entonces A decidible
A indecidible entonces B indecidible

$A_{TM} \leq H_{TM}$

$E_{TM} \leq EQ_{TM}$
$<M> \rightarrow <M,M_2>$, $M_2$ rechaza todas las codificaciones

$<M> \in E_{TM} \leftrightarrow L(M) = \emptyset \leftrightarrow L(M) = L(M_2) \leftrightarrow <M_1,M_2> \in EQ_{TM}$

$E_{TM}$ es indecidible 
$\overline{E_{TM}}$ es indecidible 
$<M, w>$
$M_1$ = "Con entrada x
\begin{enumerate}
	\item Si $x \neq w$, $\underline{rechaza}$
	\item Ejecuta M con entrada w
	\item Si M acepta, $\underline{acepta}$
\end{enumerate}

$L(M_1) = \emptyset \text{si w} \notin L(M) |w| \text{si w} \in L(M)$

$<M, w> \rightarrow <M_1>$

$<M_1,w> \in A_{TM} \leftrightarrow$ M acepta a w $\leftrightarrow L(M_1) \neq \emptyset \leftrightarrow <M_1> \notin E_{TM}$ 

$\bf{Obs}$ L es decidible si y sólo si $\overline{L}$ complemento es decidible.

Dem: Si R decide a L proponemos a S dada por:
S = "Con entrada w
\begin{enumerate}
	\item Ejecuta R con entrada w
	\item Si R acepta, $\underline{rechaza}$ y s R rechaza, $\underline{acepta}$
\end{enumerate}

$\bf{Obs}$ Si $A \leq_{M} B$ entonces $ \overline{A}\leq_{M} \overline{B}$.
Dem: f computable tal que $w \in A$ si y sólo si $f(w) \in B$ luego $e \notin A$ si y sólo si $f(w) \notin B$

$\bf{Obs}$ Si $A \leq_{M} B$ y B es reconocible, entonces A es reconocible
R es un reconocedor $f(w) \in B$ si y sólo si $w \in A$
S = "Con entrada w
\begin{enumerate}
	\item Calcular f(w)
	\item Ejecutar R con entrada f(w)
	\item Responder lo mismo que R"
\end{enumerate}

$S(w) = R(f(w))$


$A_{TM} \leq \overline{E_{TM}} \Rightarrow \overline{A_{TM}} \leq E_{TM}$

$\overline{E_{TM}}$ es reconocible

$A_{TM} \leq_M \overline{E_{TM}}$ ¿$A_{TM} \leq_M E_{TM}$? No

$\overline{A_{TM}} \leq_M \overline{E_{TM}} \Rightarrow \overline{E_{TM}}$ no es reconocible !\\

$\bf{Prop}$ $EQ_{TM}$ no es reconocible ni co-reconocible.

$A_{TM} \leq \overline{EQ_{TM}}$
$A_{TM} \leq EQ_{TM}$
Dem: F = "Con entrada <M,w> donde M es una MT
\begin{enumerate}
	\item Construimos las MT $M_1$ y $M_2$ dadas por 
	$M_1$ = "Con entrada x:
	\begin{enumerate}
		\item $\underline{Rechaza}$"
	\end{enumerate}
	$M_2$ = "Con entrada x:
	\begin{enumerate}
		\item Ejecuta a M con entrada w.
			  Si M acepta, $\underline{acepta}$
	\end{enumerate}
	\item Devuelve $<M_1, M_2>$
\end{enumerate}
Notemos que $L(M_1) = \emptyset$ y $L(M_2) = \Sigma^{*}$ si M acepta a w o $\emptyset$ si M no acepta a w.

Si $<M,w> \in A_{TM}$, entonces $L(M_2) = \Sigma^{*}$ y $<M_1,M_2> \in \overline{EQ_{TM}}$.

Si $<M_1,M_2> \in \overline{EQ_{TM}}$, entonces $L(M_2) \neq L(M_1)$, entonces $L(M_2) = \Sigma^{*}$ y por tanto M acepta a w y $<M,w> \in A_{TM}$

Luego F calcula una reducción $A_{TM} \leq_M \overline{EQ_{TM}}$

Si hacemos que $M_1$ acepte en lugar de rechazar, tenemos que:
Si $<M,w> \in A_{TM}$, entonces $L(M_2) = \Sigma^{*}$ y $<M_1,M_2> \in EQ_{TM}$.

Si $<M_1,M_2> \in EQ_{TM}$, entonces $L(M_2) \neq L(M_1)$, entonces $L(M_2) = \Sigma^{*}$ y por tanto M acepta a w y $<M,w> \in A_{TM}$

\section{Complejidad}

Vamos a trabajar únicamente con máquinas de Turing decidibles

Sea M una MT que se detiene en todas sus entradas. La complejidad (en tiempo) de M es la función $f: \mathds{N} \rightarrow \mathds{N}$ tal que $f(n)$ es el mejor tiempo que puede tardarse M en ejecutarse con una entrada de longitud n. Si $f(n)$ es el tiempo de ejecución de M, diremos que M corre en tiempo $f(n)$ o que M es de tiempo $f(n)$.

Sea $t: \mathds{N} \rightarrow \mathds{R}$ una función. La clase de de complejidad en tiempo TIME(t(n)) es el conjunto de todos los lenguajes decidibles en tiempo $\mathcal{O}(t(n))$ por una MT

$L = \{0^{n}1^{n}\} n \in \mathds{N}$
M = "Con entrada w:
\begin{enumerate}
	\item Recorre la cinta y si encuentra un 1 a la derecha de un 0, $\underline{rechaza}$ ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 y 1 en la cinta 
	\item Recorre la cinta(entrada) y borra el primer 0 y el primer 1. ($\mathcal{O}(n) \cdot \frac{n}{2}$) 
	\item Si sobra algún 0 o algún 1 en la cinta $\underline{rechaza}$. Si no, $\underline{acepta}$". ($\mathcal{O}(n)$)
\end{enumerate}

$M \in TIME(n^2)$ M es de tiempo $\mathcal{O}(n^{2})$
$L \in TIME(t(n))$

$TIME(n) \subseteq TIME(n^2)$


$M_2$ (Máquina de Turing con 2 cintas)= "Con entrada w:
\begin{enumerate}
	\item Recorre la entrada y $\underline{rechaza}$ si hay un 0 a la derecha de 1. ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 y en 1 en la cinta ($\mathcal{O}(\log{n})$)
	\item Revisa si el número de 0 y 1 es par o impar. Si es impar, $\underline{rechaza}$ ($\mathcal{O}(n)$)
	\item Recorre la cinta borrando un 0 si y uno no y un 1 si y uno no, empezando por el primero. ($\mathcal{O}(n)$)
	\item Si hay 0 o 1 en la cinta, $\underline{rechaza}$. Si no, $\underline{acepta}$" ($\mathcal{O}(n)$)
\end{enumerate}

$\mathcal{O}(n) + \mathcal{O}(\log{n}) \cdot 2\cdot \mathcal{O}(n)  + \mathcal{O}(n) = \mathcal{O}(n \log{n})$

$M_2$ corre en tiempo $\mathcal{O}(n \log{n})$ ó $\Theta(n \log{n})$

$L \in TIME(n\log{n})$
$L \in TIME(n^2)$


$M_3$ (Máquina de Turing con 3 cintas)= "Con entrada w:
\begin{enumerate}
	\item Recorre la entrada y copia los 0 en la cinta 2 y los 1 en la cinta 3 ($\mathcal{O}(n)$)
	\item Repite mientras haya 0 en la cinta 2 y 1 en la cinta 3 ($\mathcal{O}(n)$)
	\item Borra un 0 en la cinta 2 y un 1 en la cinta 3. ($\mathcal{O}(1)$)
	\item Si los 0 se acaban antes que los 1, o viceversa, $\underline{rechaza}$. De otro modo $\underline{acepta}$". ($\mathcal{O}(n)$)
\end{enumerate}

$M_3$ corre en tiempo $\mathcal{O}(n)$

$L \in TIME(n \log{n})$ 
Cambiando el modelo $\rightarrow L \in TIME(n)$

$\bf{Teo}$ Sea t(n) una función con $t(n) \geq n$
Entonces toda MT multicinta de tiempo t(n) tiene una MT de una sola cinta equivalente y de tiempo $\mathcal{O}(t(n^2))$

Dem: Utilizamos la simulación de una MT multicinta M con una MT de una sola cinta S.
Para simular un paso de M, S recorre la entrada y ubica el símbolo que lee cada cabezal virtual; esto lleva tiempo la longitud de la cadena actualmente en su cinta. Esta longitud es la suma de las longitudes de los contenidos de todas las cintas de M. Cada cinta de M contiene a lo más t(n) símbolos (pues se ejecuta por a lo más tiempo t(n)) En total, este paso se lleva tiempo $k \cdot t(n) \in \mathcal{O}(t(n))$
Después, recorre nuevamente la cinta, actualizando las acciones de M. Quizá, haciendo k shifts en el proceso. Este recorrido junto con los shifts se lleva tiempo $ k \cdot \mathcal{O}(t(n))$ que es $\mathcal{O}(t(n))$. Así, S se tarda $\mathcal{O}(t(n))$ en simular un paso de M, y tiene que simular t(n) pasos, luego el tiempo total es $\mathcal{O}(t(n)^2) \blacksquare$.

N es una MTN t(n) $\rightarrow$ existe M MTD equivalente $\mathcal{O}(2^{t(n)})$
\end{document}

